<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>tsquery——一个方便的ast查询工具</title>
    <link href="/archives/2018/09/15/tsquery%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E7%9A%84ast%E5%B7%A5%E5%85%B7/"/>
    <url>/archives/2018/09/15/tsquery%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E7%9A%84ast%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在给公司的 web 框架做一个 vscode 的辅助插件，其中有个对需要路由一些文件进行解析，实现配置文件和对应文件的关联信息显示和跳转的功能。既然是对文件进行解析，很自然就会想到使用 ast 的方式来做，加上需要对 TypeScript 也进行支持，我便选择了使用 TypeScript 自带的 ast 工具来进行解析。</p><p>在一开始我通过 ts 的<code>forEachChild</code>方法遍历和对比节点的<code>kind</code>属性来确定是否是我需要处理的节点，但是之后发现这个方式有几个缺点：</p><ol><li>当需要查找满足条件的子级的 ast 节点时，需要做多次比较</li><li>对满足某一条件的多个不同类型的节点需要比较多次，编写满足条件麻烦</li><li>对分布在同一文件中的多个同名标识符，不能统一提取和处理</li></ol><p>为了解决这些，我找到并引入了<a href="https://github.com/phenomnomnominal/tsquery"><code>tsquery</code></a>这个库，它是 TypeScript 版的<a href="https://github.com/estools/esquery"><code>esquery</code></a>，能够让我们使用 css 选择器的方式来快速查询满足指定条件的 TypeScript ast 节点（也支持 JavaScript）。</p><span id="more"></span><h2 id="比较-demo"><a href="#比较-demo" class="headerlink" title="比较 demo"></a>比较 demo</h2><p>在介绍 tsquery 的使用方式之前，我们先来看一个对比。</p><p>对下面这段简单的代码：</p><figure class="highlight ts"><figcaption><span>code.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若我们要查找到 Animal 这个类的构造函数的所有参数并打印它们的名称，在使用 tsquery 之前，我们会编写这样一段代码：</p><figure class="highlight ts"><figcaption><span>tsAnalyze.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">ClassDeclaration</span>,<br>  createSourceFile,<br>  <span class="hljs-title class_">Node</span>,<br>  <span class="hljs-title class_">ScriptTarget</span>,<br>  <span class="hljs-title class_">ConstructorDeclaration</span>,<br>  <span class="hljs-title class_">SyntaxKind</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;TypeScript&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; code &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./code&quot;</span>;<br><br><span class="hljs-keyword">const</span> sourceFile = <span class="hljs-title function_">createSourceFile</span>(<br>  <span class="hljs-string">&quot;fileName&quot;</span>,<br>  code,<br>  <span class="hljs-title class_">ScriptTarget</span>.<span class="hljs-property">Latest</span>,<br>  <span class="hljs-literal">true</span><br>);<br>sourceFile.<span class="hljs-title function_">forEachChild</span>(findClass);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findClass</span>(<span class="hljs-params">node: Node</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">kind</span> === <span class="hljs-title class_">SyntaxKind</span>.<span class="hljs-property">ClassDeclaration</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; name &#125; = node <span class="hljs-keyword">as</span> <span class="hljs-title class_">ClassDeclaration</span>;<br>    <span class="hljs-keyword">if</span> (name &amp;&amp; name.<span class="hljs-property">text</span> === <span class="hljs-string">&quot;Animal&quot;</span>) &#123;<br>      node.<span class="hljs-title function_">forEachChild</span>(findConstructor);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  node.<span class="hljs-title function_">forEachChild</span>(findClass);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findConstructor</span>(<span class="hljs-params">node: Node</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">kind</span> === <span class="hljs-title class_">SyntaxKind</span>.<span class="hljs-property">Constructor</span>) &#123;<br>    <span class="hljs-title function_">printParameters</span>(node <span class="hljs-keyword">as</span> <span class="hljs-title class_">ConstructorDeclaration</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printParameters</span>(<span class="hljs-params">node: ConstructorDeclaration</span>) &#123;<br>  node.<span class="hljs-property">parameters</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">parameter</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parameter.<span class="hljs-property">name</span>.<span class="hljs-title function_">getText</span>());<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>而在我们引入了 tsquery 之后，只需要下面这么几行简单的代码：</p><figure class="highlight ts"><figcaption><span>tsqueryAnalyze.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; tsquery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@phenomnomnominal/tsquery&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ts <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;TypeScript&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; code &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./code&quot;</span>;<br><br><span class="hljs-keyword">const</span> parameters = tsquery.<span class="hljs-property">query</span>&lt;ts.<span class="hljs-property">ParameterDeclaration</span>&gt;(<br>  code,<br>  <span class="hljs-string">&#x27;ClassDeclaration[name.name=&quot;Animal&quot;] &gt; Constructor &gt; Parameter&#x27;</span><br>);<br>parameters.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param.<span class="hljs-property">name</span>.<span class="hljs-title function_">getText</span>()));<br></code></pre></td></tr></table></figure><p>怎么样，是不是对比强烈，让你迫不及待得想把 tsquery 用到自己的项目中？</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>那么接下来，我就来介绍一下如何去使用 tsquery：</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>tsquery 对象提供了下面几个方法：</p><ul><li>ast:</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ast</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, fileName?: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">SourceFile</span>;<br></code></pre></td></tr></table></figure><p>ast 方法的功能如同其名，就是接收源代码，返回一个解析后的 ast 语法树，实际上就是调用了 ts 的<code>createSourceFile</code>方法。</p><ul><li>parse:</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">selector: <span class="hljs-built_in">string</span>, options?: TSQueryOptions</span>): <span class="hljs-title class_">TSQuerySelectorNode</span>;<br></code></pre></td></tr></table></figure><p>parse 方法接收一个规则字符串，这个字符串会被解析成 tsquery 的选择器对象并返回，再被用于下面的 match 方法中。</p><ul><li>match:</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> match&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> = <span class="hljs-title class_">Node</span>&gt;(<br>  <span class="hljs-attr">ast</span>: <span class="hljs-title class_">Node</span> | <span class="hljs-title class_">TSQueryNode</span>&lt;T&gt;,<br>  <span class="hljs-attr">selector</span>: <span class="hljs-title class_">TSQuerySelectorNode</span>,<br>  options?: <span class="hljs-title class_">TSQueryOptions</span><br>): <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">TSQueryNode</span>&lt;T&gt;&gt;;<br></code></pre></td></tr></table></figure><p>match 方法接收一个 ast 对象和一个 parse 解析后得到的选择器对象，返回从 ast 中搜索得到的所有满足选择器条件的节点的数组。</p><p>结合上面三个函数，我们可以得到 tsquery 的基本使用方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> ast = tsquery.<span class="hljs-title function_">ast</span>(code); <span class="hljs-comment">// 获得ast语法树</span><br><span class="hljs-keyword">const</span> selector = tsquery.<span class="hljs-title function_">parse</span>(selectorStr); <span class="hljs-comment">// 获得选择器</span><br><span class="hljs-keyword">const</span> result = tsquery.<span class="hljs-title function_">match</span>(ast, selector); <span class="hljs-comment">// 查找节点</span><br></code></pre></td></tr></table></figure><p>如果语法树和选择器可能被多次使用，则建议使用变量将它们分别保存下来，避免重复解析导致的资源浪费和时间开销（ast 的生成和遍历还是比较花时间的）。</p><p>如果语法树和选择器不会被重复使用，那么可以使用更简单的方法 <code>query</code>。</p><ul><li>query:</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> query&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> = <span class="hljs-title class_">Node</span>&gt;(<br>  <span class="hljs-attr">ast</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Node</span> | <span class="hljs-title class_">TSQueryNode</span>&lt;T&gt;,<br>  <span class="hljs-attr">selector</span>: <span class="hljs-built_in">string</span>,<br>  options?: <span class="hljs-title class_">TSQueryOptions</span><br>): <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">TSQueryNode</span>&lt;T&gt;&gt;;<br></code></pre></td></tr></table></figure><p>query 封装了 ast、parse 和 match 三个方法，可以更方便地完成一次查询，同时 tsquery 自身也是一个 query 方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> result = tsquery.<span class="hljs-title function_">query</span>(code, selectorStr);<br><span class="hljs-comment">// const result = tsquery(code, selectorStr);</span><br></code></pre></td></tr></table></figure><h3 id="选择器规则"><a href="#选择器规则" class="headerlink" title="选择器规则"></a>选择器规则</h3><ul><li>通用选择器</li></ul><p>和 css 中的一样，<code>*</code>表示选择所有的节点。</p><ul><li>AST 节点类型选择器</li></ul><p>你可以直接使用一个 ast 节点的类型来当作查询的选择器，例如：类声明: <code>ClassDeclaration</code>，变量声明：<code>VariableDeclaration</code>等，就跟你使用 css 选择器选择某种 HTML 元素一样。</p><ul><li>属性选择器</li></ul><p>tsquery 支持使用 css 中属性选择器的方式来搜索满足属性条件的节点，你可以仅仅只声明一个属性的名称（例如：<code>[text]</code>），也可以指定属性的值所满足的条件（例如：<code>[text=&quot;foo&quot;]</code>），其中操作符可以是<code>=</code>、’!&#x3D;’、’&gt;’、’&lt;’、’&lt;&#x3D;’、’&gt;&#x3D;’，值也可以是字符串、数字、正则表达式中的任意一种。<br>tsquery 支持多级的属性选择，所以你也可以使用<code>.</code>来组合属性（例如：<code>[members.length&lt;3]</code>）。</p><ul><li>常见的后代、兄弟节点选择器等</li></ul><p>后代节点选择器：<code>node otherNode</code><br>子节点选择器：<code>node &gt; otherNode</code><br>同级节点选择器：<code>node ~ otherNode</code><br>相邻节点选择器：<code>node + otherNode</code><br>群组选择器：<code>node, otherNode</code></p><ul><li>各种特殊的选择器</li></ul><p>not 选择器：<code>:not(ClassDeclaration)</code> 用来选择所有不是类声明的节点<br>has 选择器：<code>IfStatement:has([left.text=&quot;foo&quot;])</code> 用来选择含有符合<code>[left.text=&quot;foo&quot;]</code>属性选择器的子节点的 if 语句<br>第 n 个节点的选择器：包含 <code>:first-child</code>、<code>:last-child</code>、<code>:nth-child(n)</code>、<code>:nth-last-child(n)</code> 这几种选择器，其中需要注意的是，tsquery 并不支持<code>an+b</code>这种类型的序号匹配<br>类型选择器：区分于 AST 节点类型选择器，这个选择器是用来选择某种共通类型的（比如所有声明、所有表达式等），目前支持的有<code>:statement</code>, <code>:expression</code>, <code>:declaration</code>, <code>:function</code>, 和 <code>:pattern</code></p><p>以上所有的选择器都可以混合使用</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>tsquery 是一个非常方便和值得使用的 ast 辅助工具，它使用极为简单的 api 和学习成本较低的选择器规则，提供了对抽象和复杂的 AST 语法树较强的查询能力，可以在我们对 AST 进行处理时节省大量的编写成本。</p><p>如果你对 tsquery 的选择器规则抱有疑问，可以在 <a href="https://tsquery-playground.firebaseapp.com/">TSQuery Playground</a> 上进行在线的测试。</p><p><strong>参考内容：</strong></p><ul><li><a href="https://medium.com/@phenomnominal/easier-TypeScript-tooling-with-tsquery-d74f04f2b29d">Easier TypeScript tooling with TSQuery</a></li></ul><p>在文章最后打个招聘广告：</p><p>有赞招聘前端工程师，实习、校招、社招都可，具体要求可以参考<a href="https://job.youzan.com/">https://job.youzan.com/</a>，同时您也可以将简历投递到我的内推邮箱：<a href="mailto:&#122;&#104;&#x61;&#110;&#103;&#x73;&#x68;&#105;&#107;&#x61;&#105;&#64;&#121;&#111;&#117;&#x7a;&#97;&#x6e;&#46;&#99;&#111;&#109;">&#122;&#104;&#x61;&#110;&#103;&#x73;&#x68;&#105;&#107;&#x61;&#105;&#64;&#121;&#111;&#117;&#x7a;&#97;&#x6e;&#46;&#99;&#111;&#109;</a></p>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>ast</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用纯前端的方式来实现图片转字符画</title>
    <link href="/archives/2018/05/21/%E7%94%A8%E7%BA%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/"/>
    <url>/archives/2018/05/21/%E7%94%A8%E7%BA%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<p>最近花了几天时间，做了一个图片转字符画的工具，一开始想做成服务器来生成图像的形式，但是后来发现可以不依赖服务器生成图片，顺便还能把项目托管到 Github Pages 上，因此就把项目做成了纯前端的形式。</p><p><a href="https://github.com/kainstar/image-to-text">仓库地址</a></p><p><a href="https://kainstar.github.io/image-to-text/">演示地址</a></p><p>欢迎 star，谢谢！</p><span id="more"></span><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><ul><li>纯前端项目，不依赖服务器</li><li>支持 jpg，png，gif 三种格式图片</li><li>使用 canvas 来实现单帧图片的解析、缩放和生成，使用 gif.js 合并单帧图片为 gif 图片</li><li>可等比缩放图片</li><li>可自定义文字和背景颜色</li><li>可自定义转换时使用的字符</li><li>部分方法实现参考已在源码中标明出处</li></ul><h2 id="项目使用技术栈"><a href="#项目使用技术栈" class="headerlink" title="项目使用技术栈"></a>项目使用技术栈</h2><ul><li>webpack</li><li>React</li><li>gif.js （生成 gif 图片用）</li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├─ <span class="hljs-attribute">src</span><br>│   ├─ component 组件文件<br>│   ├─ style 样式文件<br>│   ├─ tools 图片解析、转化工具文件<br>│   ├─ App<span class="hljs-selector-class">.jsx</span><br>│   ├─ index<span class="hljs-selector-class">.js</span><br>│   └─ index<span class="hljs-selector-class">.html</span><br>├─ static<br>│   └─ js<br>│       └─ gif<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.js</span> gif.js生成图片依赖文件<br>├─ webpack<br>│    └─ webpack 配置文件<br>└ 其他文件<br></code></pre></td></tr></table></figure><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><img src="/archives/2018/05/21/%E7%94%A8%E7%BA%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/basic.gif" class="" title="basic"><h3 id="图片大小缩放"><a href="#图片大小缩放" class="headerlink" title="图片大小缩放"></a>图片大小缩放</h3><img src="/archives/2018/05/21/%E7%94%A8%E7%BA%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/size.gif" class="" title="size"><h3 id="设置颜色（文字和背景）"><a href="#设置颜色（文字和背景）" class="headerlink" title="设置颜色（文字和背景）"></a>设置颜色（文字和背景）</h3><img src="/archives/2018/05/21/%E7%94%A8%E7%BA%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/color.gif" class="" title="size"><h3 id="自定义转换字符"><a href="#自定义转换字符" class="headerlink" title="自定义转换字符"></a>自定义转换字符</h3><img src="/archives/2018/05/21/%E7%94%A8%E7%BA%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/custom-chars.gif" class="" title="size"><h2 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h2><h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i<br>npm run dev<br></code></pre></td></tr></table></figure><h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><h3 id="发布到-github-pages"><a href="#发布到-github-pages" class="headerlink" title="发布到 github pages"></a>发布到 github pages</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于express路由管理的几种自动化方法</title>
    <link href="/archives/2018/02/17/%E5%85%B3%E4%BA%8Eexpress%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/archives/2018/02/17/%E5%85%B3%E4%BA%8Eexpress%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们平时在使用 express 写代码的过程中，会根据类别，将路由分为多个不同的文件，然后在项目的入口文件（例如 app.js）中将其依次挂载，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> index = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/index&quot;</span>);<br><span class="hljs-keyword">const</span> user = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/user&quot;</span>);<br><span class="hljs-comment">// ...其他路由文件</span><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/&quot;</span>, index);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/user&quot;</span>, user);<br><span class="hljs-comment">// ...挂载其他路由</span><br></code></pre></td></tr></table></figure><p>但是当路由文件过多时，这样写会多出很多重复性的代码，而且当我添加一个新的路由模块时，除了编写路由文件本身，还需要到 app.js 入口文件中将新路由文件挂载上去，不够灵活，因此，我们需要想一些办法来管理我们的路由，使其能够自动化，免除频繁修改入口文件的操作。</p><span id="more"></span><h2 id="管理思路"><a href="#管理思路" class="headerlink" title="管理思路"></a>管理思路</h2><p>我们的项目目录主要是这样的：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">├─routes<br>  ├─index<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>  ├─user<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>  ├─<span class="hljs-keyword">sub</span><br>    ├─index<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>    ├─a<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>├─app<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br></code></pre></td></tr></table></figure><p>首先，我们来看一下，express 的路由管理主要由三部分组成，路由方法（method）、路由路径（path）和路由处理器（handle），一般情况下，路由方法和路由处理器是由路由文件自己来管理，在一个路由文件中，我们经常使用这样的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// routes/user.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// 路由的方法，处理器和部分路径</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;respond with a resource&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p>然后在入口文件中添加上共通的路由前缀：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/user&quot;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/user&quot;</span>));<br></code></pre></td></tr></table></figure><p>根据这种思路，我们主要处理的就是路由路径这个部分。在这个部分我们有两种处理方式，一种是根据路径和文件名自动生成路由的共通路径前缀，路由文件只编写剩余不共通部分的路径；还有一种则是路径完全由路由文件自己来管理，在挂载时直接挂载到根路径<code>&#39;/&#39;</code>上。</p><h2 id="管理实例"><a href="#管理实例" class="headerlink" title="管理实例"></a>管理实例</h2><h3 id="自动生成前缀"><a href="#自动生成前缀" class="headerlink" title="自动生成前缀"></a>自动生成前缀</h3><p>我们通过扫描项目目录，可以将文件在项目中的路径转化为 express 的路由路径模式，自动生成路由前缀，例如路由文件<code>routes/sub/a.js</code>就会为转化成路由前缀<code>/sub/a</code>，路由文件<code>a.js</code>中只要编写<code>/sub/a</code>后面的路径部分即可。</p><p><strong>项目目录为：</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">├─routes<br>  ├─index<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>  ├─user<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>  ├─<span class="hljs-keyword">sub</span><br>    ├─index<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>    ├─a<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>├─app<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br>├─helper<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br></code></pre></td></tr></table></figure><p><strong>主要的实现代码为：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// helper.js</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将文件名修正为前缀</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">String</span>&#125; <span class="hljs-variable">filename</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">String</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">filename</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    filename<br>      .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, filename.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;.&quot;</span>))<br>      <span class="hljs-comment">// 分隔符转换</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&quot;/&quot;</span>)<br>      <span class="hljs-comment">// index去除</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>)<br>      <span class="hljs-comment">// 路径头部/修正</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^[/]*/</span>, <span class="hljs-string">&quot;/&quot;</span>)<br>      <span class="hljs-comment">// 路径尾部/去除</span><br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[/]*$/</span>, <span class="hljs-string">&quot;&quot;</span>)<br>  );<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件路径转模块名（去.js后缀）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; rootDir 模块入口</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; excludeFile 要排除的入口文件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">scanDirModules</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">scanDirModules</span>(<span class="hljs-params">rootDir, excludeFile</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!excludeFile) &#123;<br>    <span class="hljs-comment">// 默认入口文件为目录下的 index.js</span><br>    excludeFile = path.<span class="hljs-title function_">join</span>(rootDir, <span class="hljs-string">&quot;index.js&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 模块集合</span><br>  <span class="hljs-keyword">const</span> modules = &#123;&#125;;<br>  <span class="hljs-comment">// 获取目录下的第一级子文件为路由文件队列</span><br>  <span class="hljs-keyword">let</span> filenames = fs.<span class="hljs-title function_">readdirSync</span>(rootDir);<br>  <span class="hljs-keyword">while</span> (filenames.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-comment">// 路由文件相对路径</span><br>    <span class="hljs-keyword">const</span> relativeFilePath = filenames.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-comment">// 路由文件绝对路径</span><br>    <span class="hljs-keyword">const</span> absFilePath = path.<span class="hljs-title function_">join</span>(rootDir, relativeFilePath);<br>    <span class="hljs-comment">// 排除入口文件</span><br>    <span class="hljs-keyword">if</span> (absFilePath === excludeFile) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">statSync</span>(absFilePath).<span class="hljs-title function_">isDirectory</span>()) &#123;<br>      <span class="hljs-comment">// 是文件夹的情况下，读取子目录文件，添加到路由文件队列中</span><br>      <span class="hljs-keyword">const</span> subFiles = fs<br>        .<span class="hljs-title function_">readdirSync</span>(absFilePath)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> path.<span class="hljs-title function_">join</span>(absFilePath.<span class="hljs-title function_">replace</span>(rootDir, <span class="hljs-string">&quot;&quot;</span>), v));<br>      filenames = filenames.<span class="hljs-title function_">concat</span>(subFiles);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 是文件的情况下，将文件路径转化为路由前缀，添加路由前缀和路由模块到模块集合中</span><br>      <span class="hljs-keyword">const</span> prefix = <span class="hljs-title function_">transform</span>(relativeFilePath);<br>      modules[prefix] = <span class="hljs-built_in">require</span>(absFilePath);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> modules;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后，在路由目录的入口 index 文件下，加入这么一段代码（scanDirModules 方法需要从之前编写的 helper.js 文件中引入）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> scanResult = <span class="hljs-title function_">scanDirModules</span>(__dirname, __filename);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prefix <span class="hljs-keyword">in</span> scanResult) &#123;<br>  <span class="hljs-keyword">if</span> (scanResult.<span class="hljs-title function_">hasOwnProperty</span>(prefix)) &#123;<br>    router.<span class="hljs-title function_">use</span>(prefix, scanResult[prefix]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 app.js 入口文件中只需要将所有路由相关代码改成一句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes&quot;</span>));<br></code></pre></td></tr></table></figure><p>这样就完成了路由前缀的自动生成和路由自动挂载了。</p><p>效果展示：</p><p>我们将<code>routes/sub/a.js</code>的内容定为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// routes/sub/a.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;sub/a/&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p><strong>挂载效果：</strong></p><img src="/archives/2018/02/17/%E5%85%B3%E4%BA%8Eexpress%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E6%B3%95/%E8%B7%AF%E7%94%B1%E6%8C%82%E8%BD%BD1.jpg" class="" title="路由挂载1"><p><strong>访问结果：</strong></p><img src="/archives/2018/02/17/%E5%85%B3%E4%BA%8Eexpress%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E6%B3%95/%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%9C1.jpg" class="" title="访问结果1"><p>这种自动生成前缀的方法，在路由目录层级不深时，可以起到很好的作用，但是当目录层级较多时，就会暴露出缺点：阅读代码时路由路径不明确，不能直观地看到完整路径，而且生成前缀的灵活性不高。</p><p>后者可以使用自定义导出对象和挂载方式的方法来解决，但是前者我暂时没有什么好的解决方法，因此我们来看一下之前提到的另一种自动化方法。</p><h3 id="直接挂载到根路径"><a href="#直接挂载到根路径" class="headerlink" title="直接挂载到根路径"></a>直接挂载到根路径</h3><p>这种方法的扫描思路和前一种方法相似，不同之处在于，在编写路由文件的时候，我们需要写完整路由的路径，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// routes/sub/a.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/sub/a&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;sub/a/&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><p>扫描部分的代码修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">scanDirModulesWithoutPrefix</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">scanDirModulesWithoutPrefix</span>(<span class="hljs-params"></span><br><span class="hljs-params">  rootDir,</span><br><span class="hljs-params">  excludeFile</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!excludeFile) &#123;<br>    <span class="hljs-comment">// 默认入口文件为目录下的 index.js</span><br>    excludeFile = path.<span class="hljs-title function_">join</span>(rootDir, <span class="hljs-string">&quot;index.js&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> modules = [];<br>  <span class="hljs-keyword">let</span> filenames = fs.<span class="hljs-title function_">readdirSync</span>(rootDir);<br>  <span class="hljs-keyword">while</span> (filenames.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-comment">// 路由文件相对路径</span><br>    <span class="hljs-keyword">const</span> relativeFilePath = filenames.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-comment">// 路由文件绝对路径</span><br>    <span class="hljs-keyword">const</span> absFilePath = path.<span class="hljs-title function_">join</span>(rootDir, relativeFilePath);<br>    <span class="hljs-comment">// 排除入口文件</span><br>    <span class="hljs-keyword">if</span> (absFilePath === excludeFile) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">statSync</span>(absFilePath).<span class="hljs-title function_">isDirectory</span>()) &#123;<br>      <span class="hljs-comment">// 是文件夹的情况下，读取子目录文件，添加到路由文件队列中</span><br>      <span class="hljs-keyword">const</span> subFiles = fs<br>        .<span class="hljs-title function_">readdirSync</span>(absFilePath)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> path.<span class="hljs-title function_">join</span>(absFilePath.<span class="hljs-title function_">replace</span>(rootDir, <span class="hljs-string">&quot;&quot;</span>), v));<br>      filenames = filenames.<span class="hljs-title function_">concat</span>(subFiles);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 是文件的情况下，将模块添加到模块数组中</span><br>      modules.<span class="hljs-title function_">push</span>(<span class="hljs-built_in">require</span>(absFilePath));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> modules;<br>&#125;;<br></code></pre></td></tr></table></figure><p>路由入口文件修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取 routes 目录下所有路由模块，并挂载到一个路由上</span><br><span class="hljs-keyword">const</span> routeModules = <span class="hljs-title function_">scanDirModulesWithoutPrefix</span>(__dirname, __filename);<br>routeModules.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">routeModule</span>) =&gt;</span> &#123;<br>  router.<span class="hljs-title function_">use</span>(routeModule);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>挂载效果：</strong></p><img src="/archives/2018/02/17/%E5%85%B3%E4%BA%8Eexpress%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E6%B3%95/%E8%B7%AF%E7%94%B1%E6%8C%82%E8%BD%BD2.jpg" class="" title="路由挂载2"><p>这种方法可以明确的看到路由的完整路径，在阅读代码时不会出现因为层级过深而导致出现阅读困难的情况，但是明显的缺点就是需要编写大量的路径相关代码，路径重用性又太低。</p><p>那么有没有一种方法，既能保证共通路径的重用性，又能保证代码的可阅读性呢？</p><p>有，我们可以用 JavaScript 的装饰器（Decorator）来进行路由的管理。</p><h2 id="装饰器实现路由管理"><a href="#装饰器实现路由管理" class="headerlink" title="装饰器实现路由管理"></a>装饰器实现路由管理</h2><p>装饰器的思路来自于 Java 的 MVC 框架<code>Spring MVC</code>，在 Spring MVC 中，路由的编写方式是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类上的 RequestMapping 注解用来设置共通的路径前缀</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleController</span> &#123;<br><br>  <span class="hljs-comment">// 方法上的 RequestMapping 注解用来设置剩余路径和路由方法</span><br>  <span class="hljs-meta">@RequestMapping(&quot;/&quot;, method=RequestMethod.GET)</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// GetMapping 注解相当于已经指定了GET访问方法的 RequestMapping</span><br>  <span class="hljs-meta">@GetMapping(&quot;/1&quot;)</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!1&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 ES6 之后，在 js 中编写类已经变得非常容易，我们也可以仿照 Spring MVC 的路由方式来管理 express 中的路由。</p><h3 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h3><p>关于 JavaScript 的装饰器，可以参考这两篇文章：</p><p><a href="https://github.com/rccoder/blog/issues/23">探寻 ECMAScript 中的装饰器 Decorator</a></p><p><a href="https://juejin.im/post/59f1c484f265da431c6f8940">JS 装饰器（Decorator）场景实战</a></p><p>在进行实现之前，我们先简单整理一下实现的思路。我的思路是，为了阅读方便，每一个路由文件包括一个类（Controller），每个类上有两种装饰器。</p><p>第一种装饰器是在类上添加的，用来将这个类下面的所有方法绑定到一个共通的路由前缀上；</p><p>而第二种装饰器则是添加到类中的方法上的，用来将方法绑定到一个指定的 HTTP 请求方法和路由路径上。</p><p>这两种装饰器也都接收剩余的参数，作为需要绑定的中间件。</p><p>除了编写装饰器本身之外，我们还需要一个注册函数，用来指定需要绑定的 express 对象和需要扫描的路由目录。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了使用装饰器这个特性，我们需要使用一些 babel 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yarn add babel-register babel-preset-env babel-plugin-transform-decorators-legacy<br></code></pre></td></tr></table></figure><p>编写<code>.babelrc</code>文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;env&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;transform-decorators-legacy&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在 app.js 中注册<code>babel-register</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;babel-register&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="注册函数编写"><a href="#注册函数编写" class="headerlink" title="注册函数编写"></a>注册函数编写</h3><p>注册函数的功能较为简单，因此我们先来编写注册函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扫描并引入目录下的模块</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; routesDir 路由目录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scanDirModules</span>(<span class="hljs-params">routesDir</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(routesDir)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> filenames = fs.<span class="hljs-title function_">readdirSync</span>(routesDir);<br>  <span class="hljs-keyword">while</span> (filenames.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-comment">// 路由文件相对路径</span><br>    <span class="hljs-keyword">const</span> relativeFilePath = filenames.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-comment">// 路由文件绝对路径</span><br>    <span class="hljs-keyword">const</span> absFilePath = path.<span class="hljs-title function_">join</span>(routesDir, relativeFilePath);<br>    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">statSync</span>(absFilePath).<span class="hljs-title function_">isDirectory</span>()) &#123;<br>      <span class="hljs-comment">// 是文件夹的情况下，读取子目录文件，添加到路由文件队列中</span><br>      <span class="hljs-keyword">const</span> subFiles = fs<br>        .<span class="hljs-title function_">readdirSync</span>(absFilePath)<br>        .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> path.<span class="hljs-title function_">join</span>(absFilePath.<span class="hljs-title function_">replace</span>(routesDir, <span class="hljs-string">&quot;&quot;</span>), v));<br>      filenames = filenames.<span class="hljs-title function_">concat</span>(subFiles);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// require路由文件</span><br>      <span class="hljs-built_in">require</span>(absFilePath);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册express服务器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; options 注册选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">express.Application</span>&#125; options.app express服务器对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string|Array&lt;string&gt;</span>&#125; options.routesDir 要扫描的路由目录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">options</span>) &#123;<br>  app = options.<span class="hljs-property">app</span>;<br>  <span class="hljs-comment">// 支持扫描多个路由目录</span><br>  <span class="hljs-keyword">const</span> routesDirs =<br>    <span class="hljs-keyword">typeof</span> options.<span class="hljs-property">routesDir</span> === <span class="hljs-string">&quot;string&quot;</span><br>      ? [options.<span class="hljs-property">routesDir</span>]<br>      : options.<span class="hljs-property">routesDir</span>;<br>  routesDirs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">dir</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">scanDirModules</span>(dir);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过获取 express 的 app 对象，将其注册到文件的顶级变量 app，可以让其余的装饰器函数访问到 app 对象从而完成路由注册。</p><p><code>routesDir</code>可以是字符串也可以是字符串的数组，代表了需要扫描的路由目录，将其转化为字符串数组后依次进行扫描。</p><p><code>scanDirModules</code>方法与之前的扫描方法类似，只是这里只需要将路由文件 require 进来就行，不需要返回。</p><h3 id="装饰器编写"><a href="#装饰器编写" class="headerlink" title="装饰器编写"></a>装饰器编写</h3><p>装饰器部分分为两部分，装饰类的路由装饰器<code>Router</code>和其余装饰方法的请求处理装饰器（<code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Delete</code>, <code>All</code>, <code>Custom</code>）。</p><p>在方法装饰器的编写上，由于装饰器的行为相似，因此我们可以编写一个抽象函数，用来生成不同 HTTP 请求方法的不同装饰器。</p><p>抽象函数的具体代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成对应HTTP请求方法的装饰器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; httpMethod 请求方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string|RegExp</span>&#125; pattern 请求路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;Function&gt;</span>&#125; middlewares 中间件数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">MethodDecorator</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateMethodDecorator</span>(<span class="hljs-params">httpMethod, pattern, middlewares</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, methodName, descriptor</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!target.<span class="hljs-property">_routeMethods</span>) &#123;<br>      target.<span class="hljs-property">_routeMethods</span> = &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 为自定义方法生成对应的方法存储对象</span><br>    <span class="hljs-keyword">if</span> (!target.<span class="hljs-property">_routeMethods</span>[httpMethod]) &#123;<br>      target.<span class="hljs-property">_routeMethods</span>[httpMethod] = &#123;&#125;;<br>    &#125;<br>    target.<span class="hljs-property">_routeMethods</span>[httpMethod][pattern] = [<br>      ...middlewares,<br>      target[methodName],<br>    ];<br>    <span class="hljs-keyword">return</span> descriptor;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>target</code>表示类的原型对象，<code>methodName</code>则是需要装饰的类方法的名称，我们将类方法和它的前置中间件组成一个数组，存储到类原型对象上的<code>_routeMethods</code>属性中，以便类装饰器调用。</p><p>要生成一个 HTTP 请求方法的装饰器，只需要调用这个生成函数即可。</p><p>例如生成一个 GET 方法的装饰器，则只需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * GET 方法装饰器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string|RegExp</span>&#125; pattern 路由路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;Function&gt;</span>&#125; middlewares 中间件数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">MethodDecorator</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Get</span>(<span class="hljs-params">pattern, ...middlewares</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">generateMethodDecorator</span>(<span class="hljs-string">&quot;get&quot;</span>, pattern, middlewares);<br>&#125;<br></code></pre></td></tr></table></figure><p>路由装饰器（类装饰器）的代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Router 类装饰器，使用在 class 上，生成一个带有共通前缀和中间件的路由</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string|RegExp</span>&#125; prefix 路由前缀</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">express.RouterOptions</span>&#125; routerOption 路由选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;Function&gt;</span>&#125; middlewares 中间件数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">ClassDecorator</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Router</span>(<span class="hljs-params">prefix, routerOption, ...middlewares</span>) &#123;<br>  <span class="hljs-comment">// 判断是否有路由选项，没有则当做中间件来使用</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> routerOption === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    middlewares.<span class="hljs-title function_">unshift</span>(routerOption);<br>    routerOption = <span class="hljs-literal">undefined</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 为类生成一个 router,</span><br><span class="hljs-comment">   * 该装饰器会在所有方法装饰器执行完后才执行</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; target 路由类对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>(routerOption);<br>    <span class="hljs-keyword">const</span> _routeMethods = target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_routeMethods</span>;<br>    <span class="hljs-comment">// 遍历挂载路由</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> method <span class="hljs-keyword">in</span> _routeMethods) &#123;<br>      <span class="hljs-keyword">if</span> (_routeMethods.<span class="hljs-title function_">hasOwnProperty</span>(method)) &#123;<br>        <span class="hljs-keyword">const</span> methods = _routeMethods[method];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> path <span class="hljs-keyword">in</span> methods) &#123;<br>          <span class="hljs-keyword">if</span> (methods.<span class="hljs-title function_">hasOwnProperty</span>(path)) &#123;<br>            router[method](path, ...methods[path]);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_routeMethods</span>;<br>    app.<span class="hljs-title function_">use</span>(prefix, ...middlewares, router);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 target 是类对象，当装饰器对类进行处理时，我们生成一个新的 express 路由对象，将放置在类对象原型上的_routeMethods 属性进行遍历，获取到对应的路由方法、路由路径和路由处理函数，并挂载到这个路由对象上。</p><p>需要注意，<strong>类装饰器的处理会放在方法装饰器之后进行</strong>，因此我们不能直接在方法装饰器上进行挂载，需要将其存储起来，在类装饰器上完成挂载工作。</p><h3 id="编写路由文件"><a href="#编写路由文件" class="headerlink" title="编写路由文件"></a>编写路由文件</h3><p>我们的路由文件也需要进行大幅度的改动，将其转化为下面类似的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// routes/sub/a.js</span><br><span class="hljs-comment">// Router 和 Get 装饰器从你的装饰器文件中引入</span><br>@<span class="hljs-title class_">Router</span>(<span class="hljs-string">&quot;/sub/a&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubAController</span> &#123;<br>  @<span class="hljs-title class_">Get</span>(<span class="hljs-string">&quot;/&quot;</span>)<br>  <span class="hljs-title function_">index</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;sub/a/&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">SubAController</span>;<br></code></pre></td></tr></table></figure><h3 id="挂载效果"><a href="#挂载效果" class="headerlink" title="挂载效果"></a>挂载效果</h3><img src="/archives/2018/02/17/%E5%85%B3%E4%BA%8Eexpress%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E6%B3%95/%E8%B7%AF%E7%94%B1%E6%8C%82%E8%BD%BD3.jpg" class="" title="装饰器路由挂载"><p>用装饰器编写路由的相关代码我已经单独建立了一个<a href="https://github.com/kainstar/express-derouter">github 仓库</a>，并发布成了一个 npm 包——<a href="https://www.npmjs.com/package/express-derouter">express-derouter</a>，欢迎各位 star。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我最近所思考的有关于 express 路由管理自动化的几种方法，其中装饰器挂载的方式由于 js 自身原因，在还原 Spring MVC 的其他功能上有所限制，如果你对更加强大的功能有要求的话，可以看看 TypeScript 基于 express 的一个 MVC 框架——<a href="https://nestjs.com/">nest</a>，相信它应该更能满足你的需求。</p>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在使用puppeteer前你需要做的事</title>
    <link href="/archives/2017/12/25/%E5%9C%A8%E4%BD%BF%E7%94%A8puppeteer%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    <url>/archives/2017/12/25/%E5%9C%A8%E4%BD%BF%E7%94%A8puppeteer%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>最近看了<a href="https://jeffjade.com/2017/12/17/134-kinds-of-toss-using-puppeteer/">大前端神器安利之 Puppeteer</a>这篇文章之后，想要自己试试，本文记录了我在安装 puppeteer 过程中遇到的问题和解决方案。</p><span id="more"></span><h3 id="使用-npm-和-yarn"><a href="#使用-npm-和-yarn" class="headerlink" title="使用 npm 和 yarn"></a>使用 npm 和 yarn</h3><p>我一开始直接使用官方文档中说的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add puppeteer<br><span class="hljs-comment"># or &quot;npm i puppeteer&quot;</span><br></code></pre></td></tr></table></figure><p>的方式来进行安装，但是却在一开始的安装阶段就遇到了麻烦，当我使用 npm 或 yarn 安装库时，由于 puppeteer 是使用的 chromium 内核，puppeteer 会去国外的网站上下载最新版本的 chromium，在 windows 下大约有 110MB 的大小，而且因为网络原因会下载得非常慢甚至无法下载，因此我尝试使用其他方法来安装 chromium。</p><h3 id="使用-cnpm"><a href="#使用-cnpm" class="headerlink" title="使用 cnpm"></a>使用 cnpm</h3><p>在搜索了 puppeteer 的 issues 之后，发现了这个 issues——<a href="https://github.com/GoogleChrome/puppeteer/issues/1597">Failed to download Chromium r515411</a>，下面有人给出了更换 chromium 源或使用 cnpm 安装的方式，但是经过试验发现 cnpm 安装依旧很慢，而且使用这种方式安装的话，每次新建一个项目，都要重新下载 100 多 MB 的 chromium，于是我继续尝试其他方法。</p><h3 id="使用本地-chromium"><a href="#使用本地-chromium" class="headerlink" title="使用本地 chromium"></a>使用本地 chromium</h3><p>既然是每次都需要下载 chromium，那么我们只要将 puppeteer 的 chromium 执行文件指定为本地文件就可以免除每次都重新下载的麻烦了。</p><p><strong>操作步骤：</strong></p><p>1.在<a href="https://www.chromium.org/getting-involved/download-chromium">chromium 的网站</a>上下载最新版本的 chromium,将其安装到本地</p><p>2.在设置了环境变量<code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD</code>（作用是让 puppeteer 在安装过程中跳过 chromium 的安装步骤）之后，重新安装 puppeteer：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1<br>npm i puppeteer<br></code></pre></td></tr></table></figure><p>3.然后编写你的 node 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;puppeteer&quot;</span>);<br><br>puppeteer.<span class="hljs-title function_">launch</span>(&#123;<br>  <span class="hljs-attr">executablePath</span>: <span class="hljs-string">&quot;在这里填写你本地的chromium文件地址&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样，puppeteer 就会去调用本地的 chromium 程序了。</p>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS打包工具rollup——完全入门指南</title>
    <link href="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <url>/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又是好久没有更新博客了，最近在做一个提供给浏览器和 node 同时使用的 js 的 url 模板工具类，在用什么打包工具上纠结了一段时间，正好有一天在知乎上看到了关于 rollup 的介绍，在自己试了试之后，就决定用 rollup.js 来打包自己的工具类了。</p><p>这篇文章主要是为了让对 rollup.js 也有兴趣的同学能够快速入门 rollup 的使用方式而写的，文章除了开始对 rollup.js 的基本介绍之外，主要用多个 demo 来介绍 rollup.js 的不同使用方法，以及介绍一些比较常用的 rollup 插件。读者可以选择自己有兴趣的部分查看。</p><p><a href="https://kainstar.github.io/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">文章博客链接</a></p><p>本教程相关的所有 demo 都已上传到 github，<a href="https://github.com/kainstar/rollup-demos">rollup-demos</a>，欢迎 star。</p><span id="more"></span><h2 id="rollup-js-简介"><a href="#rollup-js-简介" class="headerlink" title="rollup.js 简介"></a>rollup.js 简介</h2><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollupjs.jpg" class="" title="rollup.js"><p>首先简单介绍一下 rollup.JS。根据官方的介绍，rollup.js 是一个模块打包工具，可以帮助你从一个入口文件开始，将所有使用到的模块文件都打包到一个最终的发布文件中（极其适合构建一个工具库，这也是我选择用 rollup 来打包的原因）。</p><p>rollup.js 有两个重要的特性，其中一个就是它使用 ES6 的模块标准，这意味着你可以直接使用<code>import</code>和<code>export</code>而不需要引入 babel（当然，在现在的项目中，babel 可以说是必用的工具了）。</p><p>rollup.js 的另一个重要特性叫做’tree-shaking’，这个特性可以帮助你将无用代码（即没有使用到的代码）从最终的生成文件中删去。举个例子，我在 A.js 文件中定义了 A1 和 A2 两个方法，同时在 B 文件中引入了这两个方法，但是在 B 文件中只引入了 A 文件中的 A1 方法，那么在最后打包 B 文件时，rollup 就不会将 A2 方法引入到最终文件中。（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）</p><h2 id="rollup-js-实例"><a href="#rollup-js-实例" class="headerlink" title="rollup.js 实例"></a>rollup.js 实例</h2><h3 id="demo0-开始使用-rollup"><a href="#demo0-开始使用-rollup" class="headerlink" title="demo0 开始使用 rollup"></a>demo0 开始使用 rollup</h3><p>初始化一个工程，创建一个依赖模块文件 lib.js 和入口文件 index.js。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lib.js">export function logA() &#123;<br>    console.log(&#x27;function logA called&#x27;)<br>&#125;<br><br>export function logB() &#123;<br>    console.log(&#x27;function logB called&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs index.js">import &#123; logA &#125; from &#x27;./lib&#x27;<br><br>logA()<br></code></pre></td></tr></table></figure><p>现在我们要把 lib.js 和 index.js 打包成 dist.js，首先要做的就是安装 rollup.js。</p><p>在这里我们有两种安装方法：</p><ol><li>全局安装：</li></ol><p>打开你的命令行，输入<code>npm install rollup -g</code>，等待 rollup 安装完毕。安装完成之后，试着输入<code>rollup -v</code>来查看一下 rollup 是否安装成功了</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo0-0.png" class="" title="查看rollup版本"><p>成功安装完 rollup 之后，进入到工程目录下，输入打包命令<code>rollup index.js -o dist.js</code>，index.js 是我们的入口文件， -o 表示输出文件的路径，在 -o 后面跟着的 dist.js 就是我们要生成的最终打包文件了。（其实这里本来应该加上一个参数-i，用来表示入口文件的路径，但 rollup 是会把没有加参数的文件默认为是入口文件，因此我们在这里省略了这个参数）</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo0-1.png" class="" title="使用全局rollup进行打包"><p>显示出这条信息之后，我们发现目录下已经多出了一个 dist.js 文件，打开文件，我们发现里面的代码是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dist.js">function logA() &#123;<br>    console.log(&#x27;function logA called&#x27;);<br>&#125;<br><br>logA();<br></code></pre></td></tr></table></figure><p>此时我们就已经完成了打包作业，可以将 dist.js 引入到 HTML 文件或是 node 模块中了</p><ol start="2"><li>项目本地安装：</li></ol><p>进入到项目目录，打开命令行输入<code>npm install rollup --save-dev</code>，把 rollup 加入到开发依赖中，然后在命令行中输入<code>./node_modules/.bin/rollup index.js -o dist.js</code></p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo0-2.png" class="" title="使用项目本地rollup进行打包"><p>或者在<code>package.json</code>文件中添加 npm scripts 命令<code>&quot;build&quot;: &quot;rollup index.js -o dist.js&quot;</code>，在命令行中输入<code>npm run build</code>来进行打包</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo0-3.png" class="" title="使用项目本地rollup进行打包"><p>在打包完成之后，我们查看一下效果，新建一个 index.html 文件，在这个文件中引入我们打包出来的 dist.js 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs index.html">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;rollup 打包测试&lt;/title&gt;<br>        &lt;meta charset=&quot;UTF-8&quot;&gt;<br>        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;<br>    &lt;/head&gt;<br>    &lt;body&gt;<br>        &lt;script src=&quot;./dist.js&quot;&gt;&lt;/script&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>用浏览器打开 index.html 文件，打开控制台，我们可以看到控制台上输出了一行文字</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo0-4.png" class="" title="rollup打包文件测试"><p>使用命令行运行 dist.js 文件，我们也可以看到命令行中输出了一行文字</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo0-5.png" class="" title="rollup打包文件测试"><p>这说明我们的打包文件 dist.js 是可以运行的，打包成功。</p><p><strong>PS：</strong></p><ol><li><p>接下来的 demo 中，默认在项目内安装了 rollup</p></li><li><p>接下来的 demo 中，非必要情况下不会对打包结果进行运行结果测试，读者若需要验证打包效果，请自己编写其他测试代码。</p></li></ol><h2 id="demo1-使用-rollup-进行模块化打包"><a href="#demo1-使用-rollup-进行模块化打包" class="headerlink" title="demo1 使用 rollup 进行模块化打包"></a>demo1 使用 rollup 进行模块化打包</h2><p>在之前打包的过程中，命令行中输出了一行<code>No format option was supplied – defaulting to &#39;es&#39;</code>，这表示 rollup 并没有收到任何模块化的格式指令，因此会用默认的 es 模块标准来对文件进行打包。</p><p>如果在 demo0 中的 index.js 文件中把<code>logA()</code>改成<code>export default logA()</code>，那么 rollup 最后的打包结果就会是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dist.js">function logA() &#123;<br>    console.log(&#x27;function logA called&#x27;);<br>&#125;<br><br>var index = logA();<br><br>export default index;<br></code></pre></td></tr></table></figure><p>显然这样的代码是不能直接在浏览器端和 node 端运行的，我们需要把原先的 ES6 模块转化成浏览器和 node 支持的形式。</p><p>那么要去哪里找 rollup 把 ES6 代码转化成其他形式的方法呢？这里有两个方案，一是去<a href="https://rollupjs.org/">rollup 的官网</a>找相关的资料，二是使用 rollup 命令行的帮助命令，看看能不能找到相关的参数</p><p>我们使用 rollup 命令行的帮助命令，在命令行中输入<code>rollup -h</code></p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo1-0.png" class="" title="rollup命令行帮助"><p>在这里我们可以看到类似版本号，帮助，使用配置文件等一系列参数。在这里我们可以找到<code>-f</code>这个参数，他的说明是输出的类型（amd，cjs，es，iife，umd），从括号里的内容我们可以看出，使用这个参数可以确定打包完后的文件的模块处理方式。（如果你还不知道这几种模块之间的区别，建议先去找一下相关的资料学习一下）</p><p>接下来我们用 rollup 来打包一下，在 demo0 中的 index.js 文件里将<code>logA()</code>改成<code>export default logA()</code>，在 package.json 文件中写好不同模块的打包命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs package.json">&quot;build:amd&quot;: &quot;rollup index.js -f amd -o ./dist/dist.amd.js&quot;,<br>&quot;build:cjs&quot;: &quot;rollup index.js -f cjs -o ./dist/dist.cjs.js&quot;,<br>&quot;build:es&quot;: &quot;rollup index.js -f es -o ./dist/dist.es.js&quot;,<br>&quot;build:iife&quot;: &quot;rollup index.js -f iife -n result -o ./dist/dist.iife.js&quot;,<br>&quot;build:umd&quot;: &quot;rollup index.js -f umd -n result -o ./dist/dist.umd.js&quot;,<br>&quot;build:all&quot;: &quot;npm run build:amd &amp;&amp; npm run build:cjs &amp;&amp; npm run build:es &amp;&amp; npm run build:iife &amp;&amp; npm run build:umd&quot;<br></code></pre></td></tr></table></figure><p>在这里我们发现在设置模块为 iife（立即执行函数）和 umd 时，还加上了一个参数<code>-n</code>，这是因为我们将 logA()的结果设置为模块的输出结果，那么在使用 iife 和 umd 时，需要事先设定模块的名称，才能让其他人通过这个模块名称引用到你的模块的输出结果。</p><p>在命令行中输入<code>npm run build:all</code>，运行所有打包命令，查看效果</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo1-1.png" class="" title="demo1打包结果"><p>可以看到已经输出了 5 种不同模块标准的打包文件，由于字数原因，在这里我们只查看一个打包文件（dist.iife.js）的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dist.iife.js">var result = (function () &#123;<br>&#x27;use strict&#x27;;<br><br>function logA() &#123;<br>    console.log(&#x27;function logA called&#x27;);<br>&#125;<br><br>var index = logA();<br><br>return index;<br><br>&#125;());<br></code></pre></td></tr></table></figure><p>可以看到所有代码都被打包到了一个立即执行函数中，并且将函数的返回值（模块的输出内容）赋值给了一个全局变量，而这个全局变量的名称就是我们之前设置的模块名称。</p><p><strong>PS：</strong> 使用 amd 模块打包方式时，若不指定模块名称，则会打包成匿名函数，若想打包成一个具名函数，则需要使用<code>-u</code>或<code>--id</code>来指定具名函数名称。</p><p>除了-f 之外，还有许多其他的参数可以使用，看到这里可能有些同学会觉得麻烦了，这么多参数用起来好麻烦，每次都要输一长串的命令，那么有没有更好的方法来控制 rollup 的参数配置呢？</p><p>当然有，接下来我们就尝试使用配置文件来控制 rollup 打包。</p><h2 id="demo2-使用配置文件来进行-rollup-打包"><a href="#demo2-使用配置文件来进行-rollup-打包" class="headerlink" title="demo2 使用配置文件来进行 rollup 打包"></a>demo2 使用配置文件来进行 rollup 打包</h2><p>创建一个 demo2，沿用之前 demo1 的内容，我们在 demo2 的项目下创建一个文件，取名为<code>rollup.config.js</code>，这个文件就是 rollup 的配置文件了，rollup 根据配置文件的输出配置来进行打包，接下来我们在配置文件中输入配置代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">export default &#123;<br>  entry: &#x27;index.js&#x27;,<br>  format: &#x27;cjs&#x27;,<br>  dest: &#x27;./dist/dist.js&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>entry</code>表示打包的入口文件，<code>format</code>表示要打包成的模块类型，<code>dest</code>表示输出文件的名称路径</p><p><strong>PS：</strong> 若使用 iife 或 umd 模块打包，需要添加属性<code>moduleName</code>，用来表示模块的名称；若用 amd 模块打包，可以配置 amd 相关的参数（使用 umd 模块模式时，也会使用到 amd 相关配置参数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">amd: &#123;<br>    id: &#x27;amd-name&#x27;,   // amd具名函数名称<br>    define: &#x27;def&#x27;     // 用来代替define函数的函数名称<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们发现配置文件也是使用了 ES6 语法，这是因为 rollup 可以自己处理配置文件，所以能够直接用 ES6 的模块输出（当然，你也可以选择使用 node 的<code>module.exports</code>方式来输出配置。</p><p>在 package.json 文件中编写 npm scripts 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs package.json">&quot;build&quot;: &quot;rollup -c&quot;<br></code></pre></td></tr></table></figure><p><code>-c</code>这个参数表示使用配置文件来进行打包，若后面没有指定使用的配置文件路径，则使用默认的配置文件名称<code>rollup.config.js</code>。</p><p>在命令行中输入<code>npm run build</code>，执行打包，可以看到生成了打包文件 dist.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dist.js">&#x27;use strict&#x27;;<br><br>function logA() &#123;<br>    console.log(&#x27;function logA called&#x27;);<br>&#125;<br><br>var index = logA();<br><br>module.exports = index;<br></code></pre></td></tr></table></figure><p><strong>进阶：</strong> 当 rollup 配置文件最终输出的不是一个对象而是一个数组时，rollup 会把每一个数组元素当成一个配置输出结果，因此可以在一个配置文件内设置多种输出配置</p><p>例如，我们添加一个 indexB.js 文件，在这个文件中我们将 logA 替换为 logB，并将 rollup 配置文件改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">export default [&#123;<br>  entry: &#x27;index.js&#x27;,<br>  format: &#x27;cjs&#x27;,<br>  dest: &#x27;./dist/distA.js&#x27;<br>&#125;,&#123;<br>  entry: &#x27;indexB.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  moduleName: &#x27;indexB&#x27;,<br>  dest: &#x27;./dist/distB.js&#x27;<br>&#125;]<br></code></pre></td></tr></table></figure><p>运行打包命令，发现在 dist 目录下生成了 distA.js 和 distB.js 两个文件，说明多项配置打包成功。</p><p>除了上面这种输出一个配置数组之外，你还可以通过配置 target 属性来输出多个打包文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">export default &#123;<br>  entry: &#x27;index.js&#x27;,<br>  targets: [&#123;<br>      dest: &#x27;dist/bundle.cjs.js&#x27;,<br>      format: &#x27;cjs&#x27;<br>    &#125;,<br>    &#123;<br>      dest: &#x27;dist/bundle.umd.js&#x27;,<br>      moduleName: &#x27;res&#x27;,<br>      format: &#x27;umd&#x27;<br>    &#125;,<br>    &#123;<br>      dest: &#x27;dist/bundle.es.js&#x27;,<br>      format: &#x27;es&#x27;<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样配置会在 dist 目录下面输出<code>bundle.cjs.js</code>，<code>bundle.umd.js</code>和<code>bundle.es.js</code>三个打包文件，同时 umd 模块的名称会被定义成 res。</p><h2 id="demo3-监听文件变化，随时打包"><a href="#demo3-监听文件变化，随时打包" class="headerlink" title="demo3 监听文件变化，随时打包"></a>demo3 监听文件变化，随时打包</h2><p>我们在开发过程中，需要频繁对源文件进行修改，如果每次都自己手动输一遍打包命令，那真的是要烦死。因此，我们选择使用 rollup 提供的监听功能，安装<code>rollup-wacth</code>模块，再在 rollup 命令后面加上<code>-w</code>参数，就能让 rollup 监听文件变化，即时打包。</p><p>安装 watch 包：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>watch <span class="hljs-comment">--save-dev</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>watch <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>编写 npm scripts：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs package.json">&quot;dev&quot;: &quot;rollup -c -w&quot;<br></code></pre></td></tr></table></figure><p>执行<code>npm run dev</code>，看到下面的提示：</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo3-0.png" class="" title="rollup 监听文件变化"><p>好了，这个时候你就可以随便修改你的源文件了，rollup 会自动为你打包的。</p><p><strong>PS：</strong> 若是你不想监听某些文件，只要在配置文件中加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">watch: &#123;<br>    exclude: [&#x27;path/to/file/which/you/want/to/ignore&#x27;]<br>&#125;<br></code></pre></td></tr></table></figure><p>就行了,其中的 exclude 表示你想要忽略的文件的路径（支持 glob 模式匹配)</p><h2 id="demo4-是时候写-ES6-了"><a href="#demo4-是时候写-ES6-了" class="headerlink" title="demo4 是时候写 ES6 了"></a>demo4 是时候写 ES6 了</h2><p>ES6 可以说是现代 JS 开发 100%会用到的技术了，rollup 虽然支持了解析<code>import</code>和<code>export</code>两种语法，但是却不会将其他的 ES6 代码转化成 ES5 代码，因此我们在编写 ES6 代码的时候，需要引入插件来支持 ES6 代码的解析。</p><ol><li>安装插件和你需要的 babel preset：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>babel babel<span class="hljs-operator">-</span>preset<span class="hljs-operator">-</span>es2015 <span class="hljs-comment">--save-dev</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>babel babel<span class="hljs-operator">-</span>preset<span class="hljs-operator">-</span>es2015 <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><ol start="2"><li>创建.babalrc 文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs .babelrc">&#123;<br>  &quot;presets&quot;: [<br>    [&quot;es2015&quot;, &#123;<br>        &quot;modules&quot;: false<br>    &#125;]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以使用<code>modules:false</code>这个参数，是因为 rollup 默认是通过 ES6 模块语法来解析文件间的依赖，rollup 默认是不支持解析 common.js 的模块规范的（怎么让 rollup 支持我会在接下来的 demo 中讲解），因此需要让 babel 不转化模块相关的语法，不然 rollup 在使用过程中会报错。</p><ol start="3"><li>编写 rollup 配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">import babel from &#x27;rollup-plugin-babel&#x27;;<br><br>export default [&#123;<br>  entry: &#x27;index.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  dest: &#x27;./dist/dist.js&#x27;,<br>  plugins: [<br>    babel(&#123;<br>      exclude: &#x27;node_modules/**&#x27;<br>    &#125;)<br>  ]<br>&#125;]<br></code></pre></td></tr></table></figure><p>rollup 的配置文件的 plugins 属性可以让你添加在 rollup 打包过程中所要用到的插件，但是要注意的是，<strong>插件的添加顺序决定了它们在打包过程中的使用顺序</strong>，因此要注意配置文件的插件使用顺序。</p><ol start="4"><li>编写 ES6 代码</li></ol><p>在这里我们新建三个文件，两个类 Person 和 Man 和一个入口文件 index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Person.js">export default class Person &#123;<br>    constructor (name, gender = &#x27;男&#x27;) &#123;<br>        this.name = name<br>        this.gender = gender<br>    &#125;<br><br>    say () &#123;<br>        console.log(`我的名字是$&#123;this.name&#125;，是一个$&#123;this.gender&#125;生`)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Man.js">import Person from &#x27;./Person&#x27;<br><br>export default class Man extends Person &#123;<br>    constructor (name) &#123;<br>        super(name, &#x27;男&#x27;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs index.js">import Man from &#x27;./src/Man&#x27;<br><br>new Man(&#x27;KainStar&#x27;).say()<br></code></pre></td></tr></table></figure><ol start="5"><li>运行打包命令<code>npm run build</code></li></ol><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo4-0.png" class="" title="rollup babel打包"><p>可以看到 rollup 输出了一段提示文字，我们先不去管它，先看看打包出来的文件能不能运行，执行<code>node dist/dist.js</code></p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo4-1.png" class="" title="rollup babel打包"><p>可以看到代码运行成功了，那么我们回来继续看之前的提示文字，它的意思是’classCallCheck’这个 babel helper 函数使用了多次，rollup 推荐我们使用 external-helpers 这个插件或 es2015-rollup 这个 babel-preset 来简化打包出来的代码。</p><p>我们查看一下打包出来的 dist.js 文件，发现_classCallCheck 这个函数被定义了两次，分别被取名为_classCallCheck 和_classCallCheck$1，这样的代码肯定是可以简化的，因此我们引入 external-helpers 这个插件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i babel<span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span><span class="hljs-keyword">external</span><span class="hljs-operator">-</span>helpers <span class="hljs-comment">--save-dev</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> babel<span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span><span class="hljs-keyword">external</span><span class="hljs-operator">-</span>helpers <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>修改.babelrc 文件为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs .babelrc">&#123;<br>    &quot;presets&quot;: [<br>        [&quot;es2015&quot;, &#123;<br>            &quot;modules&quot;: false<br>        &#125;]<br>    ],<br>    &quot;plugins&quot;: [<br>        &quot;external-helpers&quot;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>或者</strong>在配置文件中使用 babel 配置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">plugins: [<br>    <span class="hljs-built_in">babel</span>(&#123;<br>        plugins: [<span class="hljs-string">&#x27;external-helpers&#x27;</span>]<br>    &#125;)<br>]<br></code></pre></td></tr></table></figure><p><strong>注意！</strong> 在 rollup-plugin-babel 的官方 github 仓库中有一段配置是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">plugins: [<br>    <span class="hljs-built_in">babel</span>(&#123;<br>      plugins: [<span class="hljs-string">&#x27;external-helpers&#x27;</span>],<br>      externalHelpers: true<br>    &#125;)<br>]<br></code></pre></td></tr></table></figure><p>这段配置的使用要求是你需要设置全局的<code>babelHelpers</code>对象，以此来将打包文件中的 babel 相关代码删除，所以一般情况下不需要使用<code>externalHelpers</code>这个属性。</p><p><strong>PS：</strong> 你也可以使用 babel-preset-es2015-rollup 这个包（搭配 babel-core），它集成了 babel-preset-es2015，babel-plugin-transform-es2015-modules-commonjs 和 babel-plugin-external-helpers 三个模块，使用起来更加方便，只要将.babelrc 文件修改成<code>&#123; &quot;presets&quot;: [&quot;es2015-rollup&quot;] &#125;</code>就可以使用了。</p><h2 id="demo5-解析-cjs，打包第三方模块"><a href="#demo5-解析-cjs，打包第三方模块" class="headerlink" title="demo5 解析 cjs，打包第三方模块"></a>demo5 解析 cjs，打包第三方模块</h2><p>有时候我们会引入一些其他模块的文件（第三方的或是自己编写的），但是这些第三方的模块为了能够直接使用，往往不是 ES6 模块而是用 commonjs 的模块方式编写的，这个时候我们需要将 commonjs 的模块转化为 ES6 模块，这样才能让 rollup 进行正确的解析。</p><ol><li>解析 commonjs</li></ol><p>解析 commonjs 需要引入一个 rollup 插件——<code>rollup-plugin-commonjs</code></p><p>安装插件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>commonjs <span class="hljs-comment">--save-dev</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>commonjs <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>在配置文件中配置插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rollup.plugin.js">import commonjs from &#x27;rollup-plugin-commonjs&#x27;<br><br>export default &#123;<br>  entry: &#x27;index_cjs.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  dest: &#x27;./js/dist_cjs.js&#x27;,<br>  plugins: [<br>    commonjs()<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>编写 cjs 模块的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lib.js">exports.logA = function logA() &#123;<br>    console.log(&#x27;function logA called&#x27;)<br>&#125;<br><br>exports.logB = function logB() &#123;<br>    console.log(&#x27;function logB called&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行打包，可以看到打包成功，也没有输出任何提示信息</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo5-0.png" class="" title="rollup cjs打包"><ol start="2"><li>打包第三方模块</li></ol><p>在打包第三方模块的过程中，rollup 无法直接解析 npm 模块，因此需要引入插件<code>rollup-plugin-node-resolve</code>并配合之前的 commonjs 插件来解析这些第三方模块</p><p>安装插件和第三方模块</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm i rollup-plugin-<span class="hljs-keyword">node</span><span class="hljs-title">-resolve</span> lodash --save-dev<br>// <span class="hljs-keyword">or</span><br>yarn add rollup-plugin-<span class="hljs-keyword">node</span><span class="hljs-title">-resolve</span> lodash --dev<br></code></pre></td></tr></table></figure><p>在配置文件中配置插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rollup.plugin.js">import commonjs from &#x27;rollup-plugin-commonjs&#x27;<br>import resolve from &#x27;rollup-plugin-node-resolve&#x27;<br><br>export default &#123;<br>  entry: &#x27;index_module.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  dest: &#x27;./js/dist_module.js&#x27;,<br>  plugins: [<br>    resolve(&#123;<br>      jsnext: true,<br>      main: true,<br>      browser: true<br>    &#125;),<br>    commonjs()<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>jsnext 表示将原来的 node 模块转化成 ES6 模块，main 和 browser 则决定了要将第三方模块内的哪些代码打包到最终文件中。</p><p>由于<a href="https://github.com/rollup/rollup-plugin-commonjs">commonjs</a>和<a href="https://github.com/rollup/rollup-plugin-node-resolve">node-resolve</a>中的配置属性很多，因此不一一解释，希望了解更多的同学可以去官方仓库查看说明。</p><p>编写入口文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs index_module.js">import compact from &#x27;lodash/compact&#x27;<br><br>const array = [0, 1, false, 2, &#x27;&#x27;, 3]<br>const compctedArray = compact(array)<br>console.log(compctedArray)<br></code></pre></td></tr></table></figure><p>在这里我们只引用了 lodash 中的 compact 方法，那么在最终代码里，应该也只会添加 compact 方法的代码。</p><p>执行打包命令，查看打包出来的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs dist_module.js">(function () &#123;<br>&#x27;use strict&#x27;;<br><br>/**<br> * Creates an array with all falsey values removed. The values `false`, `null`,<br> * `0`, `&quot;&quot;`, `undefined`, and `NaN` are falsey.<br> *<br> * @static<br> * @memberOf _<br> * @since 0.1.0<br> * @category Array<br> * @param &#123;Array&#125; array The array to compact.<br> * @returns &#123;Array&#125; Returns the new array of filtered values.<br> * @example<br> *<br> * _.compact([0, 1, false, 2, &#x27;&#x27;, 3]);<br> * // =&gt; [1, 2, 3]<br> */<br>function compact(array) &#123;<br>  var index = -1,<br>      length = array == null ? 0 : array.length,<br>      resIndex = 0,<br>      result = [];<br><br>  while (++index &lt; length) &#123;<br>    var value = array[index];<br>    if (value) &#123;<br>      result[resIndex++] = value;<br>    &#125;<br>  &#125;<br>  return result;<br>&#125;<br><br>var compact_1$1 = compact;<br><br>const array = [0, 1, false, 2, &#x27;&#x27;, 3];<br>const compctedArray = compact_1$1(array);<br>console.log(compctedArray);<br><br>&#125;());<br></code></pre></td></tr></table></figure><p>确实只添加了 compact 方法的代码，而没有将 lodash 全部引入。</p><h2 id="demo6-不要打包到一个文件，为-rollup-设置外部模块和全局变量"><a href="#demo6-不要打包到一个文件，为-rollup-设置外部模块和全局变量" class="headerlink" title="demo6 不要打包到一个文件，为 rollup 设置外部模块和全局变量"></a>demo6 不要打包到一个文件，为 rollup 设置外部模块和全局变量</h2><p>在平时的开发中，我们经常会引入其他的模块，但是在使用的时候，我们又不想把它们打包到一个文件里，想让他们作为单独的模块（或文件）来使用，方便浏览器端进行缓存，这个时候就需要使用配置文件中的<code>external</code>属性了</p><p>我们<strong>在 demo5 的基础上</strong>，把 jquery 安装到第三方模块中</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npm i jquery <span class="hljs-comment">--save-dev</span><span class="hljs-comment"></span><br><span class="hljs-comment">// or</span><br>yarn <span class="hljs-built_in">add</span> jquery <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>将配置文件改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">import commonjs from &#x27;rollup-plugin-commonjs&#x27;<br>import resolve from &#x27;rollup-plugin-node-resolve&#x27;<br><br>export default &#123;<br>  entry: &#x27;index.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  dest: &#x27;./js/dist.js&#x27;,<br>  external: [&#x27;jquery&#x27;],<br>  plugins: [<br>    resolve(&#123;<br>      jsnext: true,<br>      main: true,<br>      browser: true<br>    &#125;),<br>    commonjs()<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>external 用来表示一个模块是否要被当成外部模块使用，属性的值可以是一个字符串数组或一个方法，当传入的是一个字符串数组时，所有数组内的模块名称都会被当成是外部模块，不会被打包到最终文件中</p><p>当传入的是一个方法时，方法有一个参数 id，表示解析的模块的名称，我们可以自定义解析方式，若是要当做外部模块不打包到最终文件中，则返回 true，若要一起打包到最终文件中，则返回 false</p><p>在这里我们把 jquery 当成一个外部模块，执行打包命令：</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo6-0.png" class="" title="rollup 添加外部模块"><p>检查打包出来的文件，我们发现 lodash 的 compact 方法依旧被打包进了最终文件中，但是 jquery 却没有被打包进去，而是以$的全局变量形式被传入到了立即执行函数中。</p><p>在这里 rollup 又给我们输出了一条提示信息，意思是我们没有在配置文件中给外部模块 jquery 设置全局变量名称，因此 rollup 自己猜测了一个名称$，当成是依赖的全局变量名。</p><p>如果直接使用全局的$的话，可能会因为变量$被其他引入的代码覆盖而报错，因此我们要将$替换为不容易冲突的 jQuery 变量，在配置文件中添加<code>globals</code>属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">globals: &#123;<br>    jquery: &#x27;jQuery&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>globals 的值是一个对象，key 表示使用的模块名称（npm 模块名），value 表示在打包文件中引用的全局变量名，在这里我们就是把 jquery 模块的全局变量名设置为 jQuery，重新打包</p><p>在重新打包出来的文件中，我们发现最后传入的参数已经由<code>$</code>变为了<code>jQuery</code>，而且 rollup 也没有输出提示信息。</p><h2 id="demo7-打包-node-内置模块"><a href="#demo7-打包-node-内置模块" class="headerlink" title="demo7 打包 node 内置模块"></a>demo7 打包 node 内置模块</h2><p>有时候我们想要在浏览器端使用 node 自带的一些内置模块，一般情况下会使用<code>browserify</code>这个工具来打包，但是 browserify 打包出来的文件实在太大，因此我们用 rollup 选择性地导入我们需要的 node 内置模块</p><p>安装插件</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm i rollup-plugin-<span class="hljs-keyword">node</span><span class="hljs-title">-builtins</span> --save-dev<br>// <span class="hljs-keyword">or</span><br>yarn add rollup-plugin-<span class="hljs-keyword">node</span><span class="hljs-title">-builtins</span> --dev<br></code></pre></td></tr></table></figure><p><strong>PS：</strong> node-builtins 对不同的 node 内置模块支持不同，有些模块可能需要使用其他的插件（例如<a href="https://github.com/calvinmetcalf/rollup-plugin-node-globals">rollup-plugin-node-globals</a>）才能正常打包，具体的支持情况可以查看 node-builtins 的<a href="https://github.com/calvinmetcalf/rollup-plugin-node-builtins">官方仓库</a>。</p><p>编写配置文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> builtins <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rollup-plugin-node-builtins&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  entry: <span class="hljs-string">&#x27;index.js&#x27;</span>,<br>  format: <span class="hljs-string">&#x27;iife&#x27;</span>,<br>  dest: <span class="hljs-string">&#x27;./dist/dist.js&#x27;</span>,<br>  plugins: [<br>    builtins()<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>编写入口文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs index.js">import &#123; join &#125; from &#x27;path&#x27;<br><br>const path_base = &#x27;E://node&#x27;<br>const path_joined = join(path_basem, &#x27;bin&#x27;)<br>console.log(path_joined)<br></code></pre></td></tr></table></figure><p>在这里我们使用 node 内置的 path 模块，运行打包命令，发现 dist.js 文件中引入了额外的 100 多行代码，这 100 多行代码就实现了 path 模块的 join 方法供我们使用。</p><p><strong>PS：</strong> 我建议，如果不是必要的情况，最好能够使用其他人编写的第三方实现库或自己造轮子实现，而不是使用 node 内置的模块，因为在引用某些模块时，node-builtins 可能会引入过多的代码，这样会大大增加最后打包的文件的大小，使用他人的第三方库或自己的实现可控性更高</p><h2 id="demo8-配合-CDN-来使用-rollup"><a href="#demo8-配合-CDN-来使用-rollup" class="headerlink" title="demo8 配合 CDN 来使用 rollup"></a>demo8 配合 CDN 来使用 rollup</h2><p>有时候我们可能会使用 CDN 服务器上的 js 文件，但是又不想在本地安装一个相同的模块（也有可能没有对应的模块），可能在版本升级的时候会产生一些问题，这个时候我们就需要使用 rollup 的<code>paths</code>属性了，这个属性可以帮助你把依赖的代码文件地址注入到打包之后的文件里。</p><p>编写配置文件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  entry: <span class="hljs-string">&#x27;index.js&#x27;</span>,<br>  format: <span class="hljs-string">&#x27;amd&#x27;</span>,<br>  dest: <span class="hljs-string">&#x27;./dist/dist.js&#x27;</span>,<br>  <span class="hljs-keyword">external</span>: [<span class="hljs-string">&#x27;jquery&#x27;</span>],<br>  paths: &#123;<br>    jquery: <span class="hljs-string">&#x27;https://cdn.bootcss.com/jquery/3.2.1/jquery.js&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们要使用 cdn 上的 jquery 文件，paths 属性的值可以是一个对象或用法与<code>external</code>属性方法相似的方法（只是返回的不是 boolean 值而是文件的地址）。若使用对象来表示，则 key 值为需要引入的模块名称，value 值为对应的文件地址</p><p>编写源文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-keyword">import</span> <span class="hljs-variable">$ </span>from <span class="hljs-string">&#x27;jquery&#x27;</span><br><br><span class="hljs-variable">$(</span><span class="hljs-string">&#x27;#p&#x27;</span>).html(<span class="hljs-string">&#x27;rollup 使用paths属性配合CDN&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行打包命令，最后打包出来的文件内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dist.js">define([&#x27;https://cdn.bootcss.com/jquery/3.2.1/jquery.js&#x27;], function ($) &#123; &#x27;use strict&#x27;;<br><br>$ = $ &amp;&amp; $.hasOwnProperty(&#x27;default&#x27;) ? $[&#x27;default&#x27;] : $;<br><br>$(&#x27;#p&#x27;).html(&#x27;rollup 使用paths属性配合CDN&#x27;);<br><br>&#125;);<br></code></pre></td></tr></table></figure><p>可以看到 rollup 已经把我们需要的 CDN 地址作为依赖加入到了打包文件中。</p><h2 id="demo9-最小化你的代码"><a href="#demo9-最小化你的代码" class="headerlink" title="demo9 最小化你的代码"></a>demo9 最小化你的代码</h2><p>代码发布时，我们经常会把自己的代码压缩到最小，以减少网络请求中的传输文件大小。</p><p>rollup 的插件<code>rollup-plugin-uglify</code>就是来帮助你压缩代码的，我们接下来就用这个插件来压缩一下我们的代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>uglify <span class="hljs-comment">--save-dev</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>uglify <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">import uglify from &#x27;rollup-plugin-uglify&#x27;<br><br>export default &#123;<br>  entry: &#x27;index.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  dest: &#x27;./dist/dist.js&#x27;,<br>  plugins: [<br>    uglify()<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>运行打包命令，查看 dist.js 文件，发现代码已经被压缩了</p><p>但是，压缩过的代码在 debug 时会带来很大的不便，因此我们需要在压缩代码的同时生成一个 sourceMap 文件</p><p>幸运的是，rollup 自己就支持 sourceMap 文件的生成，不需要我们去引入其他插件，只需要在配置文件中加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sourceMap配置">sourceMap: true<br></code></pre></td></tr></table></figure><p>就可以了。</p><p>重新打包，我们发现不仅生成了 dist.js.map 文件，而且 dist 文件最后加上了一行<code>//# sourceMappingURL=dist.js.map</code>，并且在浏览器中可以正确加载源文件</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo9-0.png" class="" title="rollup sourceMap"><p><strong>PS：</strong> 若是将 sourceMap 属性的值设置为<code>inline</code>，则会将 sourceMap 的内容添加到打包文件的最后。</p><h2 id="demo10-为你的代码添-eslint-检查"><a href="#demo10-为你的代码添-eslint-检查" class="headerlink" title="demo10 为你的代码添 eslint 检查"></a>demo10 为你的代码添 eslint 检查</h2><p>在大型工程的团队开发中，我们需要保证团队代码风格的一致性，因此需要引入 eslint，而且在打包时需要检测源文件是否符合 eslint 设置的规范，若是不符合则抛出异常并停止打包。在这里我们使用 rollup 的 eslint 插件<code>rollup-plugin-eslint</code>:</p><p>安装插件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i eslint <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>eslint <span class="hljs-comment">--save-dev</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> eslint <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>eslint <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>编写 eslint 配置文件<code>.eslintrc</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;browser&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;commonjs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;es6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;parserOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;ecmaFeatures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;jsx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sourceType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;module&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;semi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;error&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;never&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在这里我们强制要求不使用分号，然后在源文件中加上一个分号</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">foo</span>(element);<br></code></pre></td></tr></table></figure><p>编写 rollup 配置文件</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> eslint <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rollup-plugin-eslint&#x27;</span>;<br><br>export <span class="hljs-keyword">default</span> &#123;<br>  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-keyword">format</span>: <span class="hljs-string">&#x27;iife&#x27;</span>,<br>  dest: <span class="hljs-string">&#x27;./dist/dist.js&#x27;</span>,<br>  plugins: [<br>    eslint(&#123;<br>      throwOnError: <span class="hljs-keyword">true</span>,<br>      throwOnWarning: <span class="hljs-keyword">true</span>,<br>      <span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;src/**&#x27;</span>],<br>      <span class="hljs-keyword">exclude</span>: [<span class="hljs-string">&#x27;node_modules/**&#x27;</span>]<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>eslint 插件有两个属性需要说明：throwOnError 和 throwOnWarning 设置为 true 时，如果在 eslint 的检查过程中发现了 error 或 warning，就会抛出异常，阻止打包继续执行（如果设置为 false，就只会输出 eslint 检测结果，而不会停止打包）</p><p>执行打包命令，发现 eslint 在输出了检查结果之后抛出了异常，而且 dist.js 文件也没有生成</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo10-0.png" class="" title="rollup eslint抛出异常"><p>删除 index.js 文件中的分号，重新打包，发现打包成功</p><p><strong>进阶：</strong> 在平时的开发过程中，我们经常会使用 IDE 或编辑器的 eslint 插件，以便提早发现问题，但是有时候这些插件会去检查打包完的文件，导致你的提示框里一直会有 eslint 检测到错误的消息</p><p>我们现在有两种解决方案，一是创建一个<code>.eslintignore</code>文件，将打包文件加进去，让 eslint 忽略这个文件</p><p>还有一种就是让 rollup 在打包文件的开始和最后自动生成注释来阻止 eslint 检测代码，使用这种方法时，需要使用 rollup 配置文件的两个属性：banner 和 footer，这两个属性会在<strong>生成文件</strong>的开头和结尾插入一段你自定义的字符串。我们利用这个属性，在打包文件的开头添加<code>/*eslint-disable */</code>注释，让 eslint 不检测这个文件。</p><p>添加 banner 和 footer 属性</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">banner:</span> <span class="hljs-comment">&#x27;/*eslint-disable */&#x27;</span><br></code></pre></td></tr></table></figure><p>重新打包，我们发现打包文件的开头被插入了这段注释字符串，而且 eslint 插件也不报 dist.js 文件的错了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*eslint-disable */</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-comment">// 具体代码</span><br><br>&#125;());<br></code></pre></td></tr></table></figure><h2 id="demo11-控制开发环境和生产环境下的配置"><a href="#demo11-控制开发环境和生产环境下的配置" class="headerlink" title="demo11 控制开发环境和生产环境下的配置"></a>demo11 控制开发环境和生产环境下的配置</h2><ol><li>配置文件的开发&#x2F;生产环境配置</li></ol><p>有时候我们会需要区分开发环境和生产环境，针对不同的打包要求输出不同的打包配置，但是我们又不想写<code>rollup.config.dev.js</code>和<code>rollup.config.prod.js</code>两个文件，因为可能两者之间的区别只是一个 uglify 插件。</p><p>因此，我们就需要用变量来控制配置文件的输出内容，rollup 命令行给我们提供了一个设置环境变量的参数<code>--environment</code>，在这个参数后面加上你需要设置的环境变量，不同变量间用逗号分隔，用冒号后面的字符串表示对应变量的值（若不加冒号，则默认将值设为字符串 true）：</p><p>在 package.json 文件中编写对应的 npm scripts 命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rollup -c --environment NODE_ENV:development&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rollup -c --environment NODE_ENV:production&quot;</span><br></code></pre></td></tr></table></figure><p>最后修改我们的 rollup 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">import uglify from &#x27;rollup-plugin-uglify&#x27;<br><br>let isProd = process.env.NODE_ENV === &#x27;production&#x27;<br><br>// 通用的插件<br>const basePlugins = []<br>// 开发环境需要使用的插件<br>const devPlugins = []<br>// 生产环境需要使用的插件<br>const prodPlugins = [uglify()]<br><br>let plugins = [...basePlugins].concat(isProd ? prodPlugins:devPlugins)<br>let destFilePath = isProd ? &#x27;./dist/dist.min.js&#x27;: &#x27;./dist/dist.js&#x27;<br><br>export default &#123;<br>  entry: &#x27;index.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  dest: destFilePath,<br>  sourceMap: isProd,<br>  plugins: plugins<br>&#125;<br></code></pre></td></tr></table></figure><p>我们分别运行两个 npm scripts 命令，查看打包的结果：</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo11-0.png" class="" title="rollup 开发环境和生产环境打包结果"><ol start="2"><li>源文件开发&#x2F;生产环境信息注入</li></ol><p>上面是在配置文件里通过变量来改变输出的配置类型，但是我们有时候需要将生产环境信息添加到源文件里，这个时候就需要使用 rollup 的配置属性 intro 和 outro 了</p><p>如果说 banner 和 footer 是在文件开始和结尾添加字符串，那么 intro 和 outro 就是在被打包的代码开头和结尾添加字符串了，以 iife 模式来举例，如果我们配置了这四个属性，那么输出结果就会是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// banner字符串</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-comment">// intro字符串</span><br><br><span class="hljs-comment">// 被打包的代码</span><br><br><span class="hljs-comment">// outro字符串</span><br>&#125;());<br><span class="hljs-comment">// footer字符串</span><br></code></pre></td></tr></table></figure><p>这样的形式</p><p>下面我们实际使用一下，在 index.js 文件里加上一段需要依赖的代码</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (DEVELOPMENT) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;处于开发环境&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;处于生产环境&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在我们的 rollup 配置文件里添加：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">intro: <span class="hljs-string">&#x27;var DEVELOPMENT = &#x27;</span> + !isProd,<br></code></pre></td></tr></table></figure><p>这样，当我们最后生成的代码时，就会输出开发环境或生产环境的提示：</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo11-1.png" class="" title="rollup 开发环境和生产环境信息打包结果"><ol start="2"><li>源文件开发&#x2F;生产环境信息替换</li></ol><p>有时候我们会把开发&#x2F;生产环境的信息直接写在源文件里面，这个时候用 intro 来注入代码的方式就不适合了。这个时候我们就需要使用<code>rollup-plugin-replace</code>插件来对源代码的变量值进行替换：</p><p>安装插件</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npm i rollup-plugin-<span class="hljs-built_in">replace</span> <span class="hljs-comment">--save-dev</span><span class="hljs-comment"></span><br><span class="hljs-comment">// or</span><br>yarn <span class="hljs-built_in">add</span> rollup-plugin-<span class="hljs-built_in">replace</span> <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">const basePlugins = [replace(&#123;<br>  DEVELOPMENT: !isProd<br>&#125;)]<br><br>// 将intro属性注释掉<br>// intro: &#x27;var DEVELOPMENT = &#x27; + !isProd,<br></code></pre></td></tr></table></figure><p>这里我们使用 replace 插件，以 key-value 对象的形式，将<code>DEVELOPMENT</code>的值替换为<code>!isProd</code>的值</p><p>执行打包命令，并检查打包结果：</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo11-2.png" class="" title="rollup 开发环境和生产环境信息打包结果"><p><strong>进阶：</strong> replace 除了直接使用 key-value 的形式替换对应 key 同名变量的方法之外，还可以通过配置<code>delimiters</code>参数来实现模板功能：</p><p>配置 replace 插件参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">VERSION: &#x27;1.0.0&#x27;,<br>delimiters: [&#x27;&#123;&#123;&#x27;, &#x27;&#125;&#125;&#x27;]<br></code></pre></td></tr></table></figure><p>通过这个配置，在打包过程中，<code>&#123;&#123;VERSION&#125;&#125;</code>会被替换成<code>1.0.0</code></p><p>在 index.js 文件内添加相关代码</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> version = <span class="hljs-string">&#x27;&#123;&#123;VERSION&#125;&#125;&#x27;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;版本 v&#x27;</span> + version)<br></code></pre></td></tr></table></figure><p>打包的结果</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> version = <span class="hljs-string">&#x27;1.0.0&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;版本 v&#x27;</span> + version);<br></code></pre></td></tr></table></figure><h2 id="demo12-使用-rollup-的-API"><a href="#demo12-使用-rollup-的-API" class="headerlink" title="demo12 使用 rollup 的 API"></a>demo12 使用 rollup 的 API</h2><p>有时候我们会需要在打包的前后执行一些其他的代码，但是又不想引入其他构建工具（例如 gulp），那么就可以使用 rollup 提供的 node API 来编写你自己的打包流程。</p><p>rollup 模块只提供了一个 rollup 函数，这个函数的参数和我们编写配置文件时导出的参数不同，减少了很多配置属性，留下来的主要是一些输入相关的配置。（具体的配置属性可以查看 rollup wiki 的<a href="https://github.com/rollup/rollup/wiki/JavaScript-API">javascript API</a>一节）</p><p>执行这个函数返回的是一个 Promise，并且在 then 方法中提供一个 bundle 对象作为参数，这个对象保存了 rollup 对源文件编译一次之后的结果，而且提供了<code>generate</code>和<code>write</code>两个方法</p><p>write 方法提供了编译并将打包结果输出到文件里的功能，返回的是一个没有参数的 Promise，可以让你自定义接下来执行的代码</p><p>generate 方法是只提供了编译的功能，返回一个 Promise，这个 Promise 有一个对象参数，包含了 code（编译完之后的代码）和 map（分析出来的 sourceMap 对象）两个属性，一般用在插件开发中</p><p>write 和 gengerate 方法都接受有编译相关属性的对象作为传入的编译参数，而 write 方法还额外接受<code>dset</code>属性作为导出文件的名称。</p><p>在这里我们只使用 write 方法来编写一个为所有模块类型打包，并输出打包完毕提示的文件，至于 generate 的使用方法我们会放在编写插件一节中介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rollup.js">const rollup = require(&#x27;rollup&#x27;).rollup<br><br>rollup(&#123;<br>    entry: &#x27;index.js&#x27;<br>&#125;).then(bundle =&gt; &#123;<br><br>    // 保存所有Promise的列表<br>    let writePromiseList = []<br>    // 声明所有需要打包的模块类型<br>    let moduleTypesList = [&#x27;es&#x27;,&#x27;cjs&#x27;,&#x27;amd&#x27;,&#x27;umd&#x27;,&#x27;iife&#x27;]<br><br>    moduleTypesList.forEach(function(moduleType) &#123;<br>        writePromiseList.push(bundle.write(&#123;<br>            dest: &#x27;./dist/dist.&#x27; + moduleType + &#x27;.js&#x27;,<br>            format: moduleType,<br>            sourceMap: true<br>        &#125;))<br>    &#125;)<br><br>    return Promise.all(writePromiseList)<br><br>&#125;).then(() =&gt; &#123;<br>    console.log(&#x27;全部模块格式打包完毕&#x27;)<br>    // 其他代码<br>&#125;)<br></code></pre></td></tr></table></figure><p>将 package.json 文件内的 npm scripts 命令修改为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node rollup.js&quot;</span><br></code></pre></td></tr></table></figure><p>执行打包命令，查看打包结果</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo12-0.png" class="" title="rollup 自定义打包结果1"><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo12-1.png" class="" title="rollup 自定义打包结果2"><p>在这里我们可以看到，一个 bundle 可以被重复使用多次，因此我们可以用 Promise.all 方法来等待所有模块打包完成后再输出打包完毕的提示。</p><h2 id="demo13-除了打包-JS，我们还能……"><a href="#demo13-除了打包-JS，我们还能……" class="headerlink" title="demo13 除了打包 JS，我们还能……"></a>demo13 除了打包 JS，我们还能……</h2><p>一个 web 项目内肯定不会只有 js 文件，还有 css、html（也可能是模板文件）和其他类型的文件，那么我们在打包的时候能不能把这些文件一起打包呢？</p><p>我们需要区分一下，在这里的打包有两种意思，一种是让这些文件可以像 JS 文件一样，在源代码中被 import 并使用；还有一种是通过在源文件中 import 这些文件，最后将它们合并到一起并导出到一个最终文件内。</p><p>不同的 rollup 插件有不同的效果，在使用的时候一定要查看插件的相关说明</p><p>安装插件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>scss <span class="hljs-comment">--save-dev</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>scss <span class="hljs-comment">--dev</span><br></code></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">import scss from &#x27;rollup-plugin-scss&#x27;<br><br>export default &#123;<br>  entry: &#x27;./src/js/index.js&#x27;,<br>  format: &#x27;iife&#x27;,<br>  dest: &#x27;./dist/js/dist.js&#x27;,<br>  sourceMap: true,<br>  plugins: [<br>    scss(&#123;<br>      output: &#x27;./dist/css/style.css&#x27;<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们尝试编译和打包 scss 文件，将其合并成一个 style.css 文件，并输出到 dist&#x2F;css 目录下</p><p>编写 scss 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bg.scss">$blue: #69c4eb;<br><br>.bg-blue &#123;<br>    background-color: $blue<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text.scss">$white: #fff;<br><br>.text-white &#123;<br>    color: $white;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在源文件中引用这两个 scss 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs index.js">import &#x27;../scss/text.scss&#x27;<br>import &#x27;../scss/bg.scss&#x27;<br><br>var html = `<br>    &lt;div class=&quot;bg-blue&quot;&gt;<br>        &lt;p class=&quot;text-white&quot;&gt;测试文字&lt;/p&gt;<br>    &lt;/div&gt;<br>`<br><br>document.body.innerHTML = html<br></code></pre></td></tr></table></figure><p>执行打包命令，查看效果</p><img src="/archives/2017/08/12/JS%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7rollup%E2%80%94%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/rollup-demo13-0.png" class="" title="rollup 打包scss效果"><h2 id="extra-编写你自己的-rollup-插件"><a href="#extra-编写你自己的-rollup-插件" class="headerlink" title="extra 编写你自己的 rollup 插件"></a>extra 编写你自己的 rollup 插件</h2><p>有时候我们可能需要自己编写 rollup 插件来实现需求，rollup 官方在 wiki 上提供了关于<a href="https://github.com/rollup/rollup/wiki/Plugins#creating-plugins">编写插件的一些介绍</a>，下面我们就根据这些介绍来写一个自己的 rollup 插件。</p><p>我们在这里仿照 scss 插件编写一个 stylus 的 rollup 插件，让使用者可以 import stylus 文件，并编译打包导出到指定的目录下（为了节省代码量，只写了输出到指定路径的功能代码，其他的功能可以参考<a href="https://github.com/thgh/rollup-plugin-scss">scss 插件</a>的具体代码）。</p><p>首先创建项目，在 package.json 文件中，除了一般信息之外，还要加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs package.json">&quot;main&quot;: &quot;index.cjs.js&quot;,<br>&quot;module&quot;: &quot;index.es.js&quot;,<br>&quot;jsnext:main&quot;: &quot;index.es.js&quot;<br></code></pre></td></tr></table></figure><p>这些信息用来区分使用不同模块规范时使用的文件</p><p>安装我们需要用到的模块</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm i <span class="hljs-keyword">rollup</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>babel babel<span class="hljs-operator">-</span>preset<span class="hljs-operator">-</span>es2015<span class="hljs-operator">-</span><span class="hljs-keyword">rollup</span> babel<span class="hljs-operator">-</span>core <span class="hljs-comment">--save-dev</span><br>npm i <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>pluginutils stylus <span class="hljs-comment">--save</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">or</span><br>yarn <span class="hljs-keyword">add</span> <span class="hljs-keyword">rollup</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>plugin<span class="hljs-operator">-</span>babel babel<span class="hljs-operator">-</span>preset<span class="hljs-operator">-</span>es2015<span class="hljs-operator">-</span><span class="hljs-keyword">rollup</span> babel<span class="hljs-operator">-</span>core <span class="hljs-comment">--dev</span><br>yarn <span class="hljs-keyword">add</span> <span class="hljs-keyword">rollup</span><span class="hljs-operator">-</span>pluginutils stylus<br></code></pre></td></tr></table></figure><p>rollup-pluginutils 和 stylus 是我们运行时需要的两个模块，stylus 用来解析 stylus 文件，<a href="https://github.com/rollup/rollup-pluginutils">pluginutils</a>则提供给了我们一些编写插件常用的函数</p><p>编写 rollup 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rollup.config.js">import babel from &#x27;rollup-plugin-babel&#x27;<br><br>export default &#123;<br>    entry: &#x27;./index.es.js&#x27;,<br>    dest: &#x27;./index.cjs.js&#x27;,<br>    format: &#x27;cjs&#x27;,<br>    plugins: [<br>        babel()<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>rollup 插件需要一个含有指定属性的对象作为插件内容，rollup 官方建议我们在编写插件的时候，export 一个返回值为插件对象的函数，这样可以方便使用者指定插件的参数。</p><p>rollup 会将解析的部分结果作为参数调用插件返回的对象中的一些函数属性，这些函数会在合适的时候被 rollup 调用（相当于 rollup 在执行各个操作时的钩子函数），下面我们介绍一些常用的属性：</p><ul><li><p>name：插件的名称，提供给 rollup 进行相关信息的输出</p></li><li><p>load：不指定这个属性时，解析模块会默认去读取对应路径文件的内容；而当该值为函数（id &#x3D;&gt; code）时，可以将函数最后的返回值作为文件的内容提供给 rollup（可以用来生成自定义格式的代码）</p></li><li><p>resolveId：一个（ (importee, importer) &#x3D;&gt; id）形式的函数，用来解析 ES6 的 import 语句，最后需要返回一个模块的 id</p></li><li><p>transform：最常使用的属性，是一个函数，当 rollup 解析一个 import 时，会获取到对应路径文件的内容，并将内容和模块的名称作为参数提供给我们；这个函数执行完毕之后，需要返回一个作为代码的字符串或是类似<code>&#123; code, map &#125;</code>结构的对象，用来表示解析完之后该模块的实际内容，map 指的是 sourceMap，而如果我们没有要导出的 sourceMap，就可以将返回的 map 值设为<code>&#123;mappings: &#39;&#39;&#125;</code></p></li><li><p>ongenerate：当我们或 rollup 调用 generate 方法时，会被调用的一个钩子函数，接受 generate 的 option 作为参数</p></li><li><p>onwrite：和 ongenerate 一样，调用 write 方法时，会被调用的一个钩子函数，接受 write 的 option 作为参数</p></li></ul><p>一般情况下，我们通过 transform 函数来获取文件的 id 和内容，并对内容做一些处理，若需要输出文件则使用 ongenerate 或 onwrite 在 rollup 打包的最后阶段来做相应的输出。</p><p>load 和 resolveId 在一般情况下不会使用，除非你有特殊的需求（例如对路径、模块 id 进行修改等)</p><p>根据上面这些内容，我们编写具体的插件内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createFilter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rollup-pluginutils&#x27;</span><br><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> stylus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;stylus&#x27;</span><br><br><span class="hljs-comment">// 递归创建文件夹</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mkdirs</span>(<span class="hljs-params">dir</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        fs.<span class="hljs-title function_">exists</span>(dir, <span class="hljs-function">(<span class="hljs-params">exist</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (exist) &#123;<br>                <span class="hljs-title function_">resolve</span>()<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">mkdirs</span>(path.<span class="hljs-title function_">dirname</span>(dir)).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    fs.<span class="hljs-title function_">mkdir</span>(dir, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>                        <span class="hljs-keyword">if</span> (err) &#123;<br>                            <span class="hljs-title function_">reject</span>()<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-title function_">resolve</span>()<br>                        &#125;<br>                    &#125;)<br>                &#125;)<br>            &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 导出一个function</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">stylusPlugin</span>(<span class="hljs-params">options = &#123;&#125;</span>) &#123;<br>    <span class="hljs-comment">// 创建一个文件过滤器，过滤以css，styl结尾的文件</span><br>    <span class="hljs-keyword">const</span> stylusFilter = <span class="hljs-title function_">createFilter</span>(options.<span class="hljs-property">include</span> || [<span class="hljs-string">&#x27;**/*.css&#x27;</span>, <span class="hljs-string">&#x27;**/*.styl&#x27;</span>], options.<span class="hljs-property">exclude</span>)<br><br>    <span class="hljs-comment">// dest用来保存指定的输出路径</span><br>    <span class="hljs-keyword">let</span> dest = options.<span class="hljs-property">output</span>,<br>    <span class="hljs-comment">// styleNodes用来暂存不同文件的css代码</span><br>        styleNodes = &#123;&#125;<br><br>    <span class="hljs-comment">// 编译stylus文件</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">complier</span>(<span class="hljs-params">str, stylusOpt</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            stylus.<span class="hljs-title function_">render</span>(str, stylusOpt, <span class="hljs-function">(<span class="hljs-params">err, css</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (err) &#123;<br>                    <span class="hljs-title function_">reject</span>(err)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">resolve</span>(css)<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">// 插件名称</span><br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rollup-plugin-stylus&#x27;</span>,<br><br>        <span class="hljs-comment">// 解析import时调用，获取文件名称和具体代码，将它们保存起来</span><br>        transform (code, id) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">stylusFilter</span>(id)) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            styleNodes[id] = code<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;,<br>        <span class="hljs-comment">// generate时调用，用stylus解析代码，并输出到指定目录中</span><br>        <span class="hljs-keyword">async</span> ongenerate (genOpt) &#123;<br>            <span class="hljs-keyword">let</span> css = <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> styleNodes) &#123;<br>                <span class="hljs-comment">// 合并所有css代码</span><br>                css += styleNodes[id] || <span class="hljs-string">&#x27;&#x27;</span><br>            &#125;<br><br>            <span class="hljs-comment">// 编译stylus代码</span><br>            <span class="hljs-keyword">if</span> (css.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    css = <span class="hljs-keyword">await</span> <span class="hljs-title function_">complier</span>(css, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, options.<span class="hljs-property">stylusOpt</span>))<br>                &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 没有指定输出文件路径时，设置一个默认文件</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dest !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!css.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br><br>                dest = genOpt.<span class="hljs-property">dest</span> || <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>                <span class="hljs-keyword">if</span> (dest.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.js&#x27;</span>)) &#123;<br>                    dest = dest.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">3</span>)<br>                &#125;<br>                dest = dest + <span class="hljs-string">&#x27;.css&#x27;</span><br>            &#125;<br><br>            <span class="hljs-comment">// 创建目录，并将css写入到结果文件内</span><br>            <span class="hljs-keyword">await</span> <span class="hljs-title function_">mkdirs</span>(path.<span class="hljs-title function_">dirname</span>(dest))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                fs.<span class="hljs-title function_">writeFile</span>(dest, css, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (err) &#123;<br>                        <span class="hljs-title function_">reject</span>(err)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-title function_">resolve</span>()<br>                    &#125;<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个解析并打包 stylus 文件的 rollup 插件就写好了，你可以在你的工程中引用这个文件，也可以将其作为一个模块发布，以便于分享给其他人使用。</p><h2 id="总结-and-一个完整的-rollup-项目的模板"><a href="#总结-and-一个完整的-rollup-项目的模板" class="headerlink" title="总结 and 一个完整的 rollup 项目的模板"></a>总结 and 一个完整的 rollup 项目的模板</h2><p>rollup 在打包 JS 上是一个十分快捷方便的工具，但和 webpack 相比，他的生态圈还是不够强大，对于大型 web 工程的适应度相对不足</p><p>rollup 的优点在于方便的配置，天然的 ES6 模块支持让我们可以直接使用 import 和 export 语法，在打包 JS 上，不实现自己的模块机制，而是使用目前常见的模块规范有助于其他工具（例如 requirejs）来引用打包文件；tree-shaking 的特性也有助于减少代码量，因此我认为 rollup 比起构建应用工程项目，更适合用来构建一个 JS 库或 node 模块</p><p>我将上面介绍的插件集合到一起，添加了测试的支持，制作了一个较为完整的 rollup 工程模板。放在<code>rollup-project-template</code>目录下，需要的同学可以自取（你也可以增加或删除任意你需要的模块，来组建属于你自己的 rollup 项目模板）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://github.com/rollup/rollup/wiki">rollup 官方 wiki</a></p></li><li><p><a href="https://github.com/rollup/rollup/wiki/Plugins">rollup 插件合集</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/28096758">如何通过 Rollup.js 打包 JavaScript —— 知乎专栏</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
      <tag>rollup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用vue制作FullPage页面</title>
    <link href="/archives/2017/04/05/%E4%BD%BF%E7%94%A8vue%E5%88%B6%E4%BD%9Cfullpage%E9%A1%B5%E9%9D%A2/"/>
    <url>/archives/2017/04/05/%E4%BD%BF%E7%94%A8vue%E5%88%B6%E4%BD%9Cfullpage%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经有好久没有更新博客了，大三下了要准备找实习了，才发现自己很多东西都不会，所以赶紧找了个现在流行的 MVVM 框架学习一下。我学习的是 Vue，所以拿 Vue 写了一个 FullPage 的模板，可以供自己和其他人使用。</p><p>项目的地址是：<a href="https://github.com/kainstar/vue-fullpage">https://github.com/kainstar/vue-fullpage</a></p><p><a href="https://kainstar.github.io/vue-fullpage">演示效果在这里</a></p><span id="more"></span><h2 id="项目讲解"><a href="#项目讲解" class="headerlink" title="项目讲解"></a>项目讲解</h2><p>为了加深理解，我把我制作这个 FullPage 页面的思路和流程记录下来，也可以给其他和我一样的初学者一个参考。</p><h3 id="分解思路"><a href="#分解思路" class="headerlink" title="分解思路"></a>分解思路</h3><p>首先，我根据 Vue 的组件开发思想，把这个 FullPage 页面分为两个主要的组件模块：页面组件（Page）和页面控制组件（PageController）。除了这两个组件模块之外，还有一个整合的 App.vue 文件。</p><p>其中，Page 组件主要负责每个 FullPage 页面的样式和位置控制，而 PageController 组件则用来发起页面的切换请求。</p><p>因为 Vue 是单向数据流形式的，因此将所有需要的数据都定义在 App.vue 文件中，由 App 组件向下传递数据。</p><h3 id="数据需求分析"><a href="#数据需求分析" class="headerlink" title="数据需求分析"></a>数据需求分析</h3><p>要制作一个 FullPage 页面，每个 Page 页面需要的是页面自身的内容（页面的内容和样式配置），而控制器所需要的数据有当前正在显示的页面以及总的页面数，用这两个属性计算出其他需要的属性。</p><p>其中，总页面数即是 Page 总数，有多少个 Page，就有多少个 Page 的配置，因此可以通过计算 Page 配置信息对象的数量来获得总页面数。</p><p>我在 App.vue 的组件 data 中定义了两个属性：</p><ul><li>currentPage 表示的是当前页面的序号（从 1 开始计算）；</li><li>options 是一个数组，其中的每一个对象表示的是对应序号的页面的配置信息，可以通过修改里面的对象属性从而改变对应 Page 的样式。</li></ul><p>Page 组件只需要知道当前页面是第几个页面和自身的配置，因此只含有两个属性：</p><ul><li>currentPage</li><li>option 表示自身的配置</li></ul><p>PageController 需要对页面进行切换控制，因此需要两个属性：</p><ul><li>currentPage</li><li>pageNum 表示总的页面数量</li></ul><h3 id="编写页面样式"><a href="#编写页面样式" class="headerlink" title="编写页面样式"></a>编写页面样式</h3><p><strong>App 组件的结构为：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- page为单独的页面组件，page内可以编写任意的页面内容 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">page</span> <span class="hljs-attr">:currentPage</span>=<span class="hljs-string">&quot;currentPage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">page</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- page-controller为控制器组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">page-controller</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:pageNum</span>=<span class="hljs-string">&quot;pageNum&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:currentPage</span>=<span class="hljs-string">&quot;currentPage&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">changePage</span>=<span class="hljs-string">&quot;changePage&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:arrowsType</span>=<span class="hljs-string">&quot;arrowsType&quot;</span></span><br><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">page-controller</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>App 组件主要样式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 页面宽高为100%，overflow为hidden隐藏溢出部分 */</span><br><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.app</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Page 组件结构为：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;options&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;background:options.background,color:options.color||&#x27;#fff&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;page-before&#x27;: options.index &lt; currentPage,&#x27;page-after&#x27;: options.index &gt; currentPage&#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;page-center&#x27;: options.isCenter&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page&quot;</span> <span class="hljs-attr">v-else</span>&gt;</span>页面正在渲染中。。。<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 slot 内为在 App.vue 的 page 标签内编写的 html 内容，并且根据 Page 组件内的 option 属性，为 Page 页面添加不同的样式（包括背景颜色、字体颜色、居中等，而且可以自由扩展）</p><p><strong>Page 组件的主要样式为：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.page</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span> ease <span class="hljs-number">0s</span>;<br>&#125;<br><span class="hljs-selector-class">.page-before</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-selector-class">.page-after</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过比较当前页面的 index 与 currentPage 的大小，可以判断 Page 组件处于之前的页面，当前的页面和之后的页面三个状态中的哪一种。</p><p>将所有页面都用 absolute 定位在同一个位置上，对于处于之前的页面的 Page，添加 page-before 类标签，使其在 Y 轴上向上偏移自身高度距离，同理，对之后的页面做 Y 轴上向下的自身高度偏移。</p><p>在 page 标签上添加 transition 样式，使其在切换时可以产生动画效果。</p><p><strong>PageController 组件的结构为：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;controller&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;arrowsType != &#x27;no&#x27;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;prev-btn&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;moving:arrowsType === &#x27;animate&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changePage(prevIndex)&quot;</span></span><br><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changePage(index)&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;index in pageNum&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;&#x27;controller-&#x27;+index&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;controller-item&quot;</span></span><br><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;arrowsType != &#x27;no&#x27;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;next-btn&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;moving:arrowsType === &#x27;animate&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changePage(nextIndex)&quot;</span></span><br><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure><p>PageController 组件中分为两块，控制上下滚动的上下箭头按钮和控制所有页面的 ul 列表。</p><p>因为 PageController 中的样式较多，因此不在文章中详细说明，只做简单介绍。</p><p>button 和 ul 标签用 fixed 定位，使其处于整个页面的上方、下方和右侧。</p><p>button 使用 rotate 和 border 属性，制作出箭头的样式，并添加对应的动画效果（可以通过传递 props 选择关闭）。</p><h3 id="编写页面逻辑"><a href="#编写页面逻辑" class="headerlink" title="编写页面逻辑"></a>编写页面逻辑</h3><h4 id="切换页面逻辑"><a href="#切换页面逻辑" class="headerlink" title="切换页面逻辑"></a>切换页面逻辑</h4><p>因为所有的页面切换都是由 PageController 发起，而控制 currentPage 的组件并不是 PageController，所以需要有一个父子组件事件，由子组件 PageController 发起，传递一个参数表示要切换到第几个页面，因此在 PageController 中定义一个 method：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">changePage (index) &#123;<br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;changePage&#x27;</span>, index);<br>&#125;<br></code></pre></td></tr></table></figure><p>父组件接受该事件并调用自己定义的 changePage 方法，修改自身的 currentPage 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">changePage (index) &#123;<br><span class="hljs-comment">// 改变page</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> = index;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="箭头按钮上下滚动"><a href="#箭头按钮上下滚动" class="headerlink" title="箭头按钮上下滚动"></a>箭头按钮上下滚动</h4><p>为了实现上下滚动，需要知道当前页面的前一个页面和后一个页面分别是第几个页面，因此可以使用计算属性，计算出前一个和后一个页面的 index 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// PageController.vue</span><br>nextIndex () &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">pageNum</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;,<br>prevIndex () &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> === <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">pageNum</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在点击箭头时，将对应的 nextIndex 或 prevIndex 值当做参数传给 changePage 方法。</p><h4 id="滚轮滚动和移动端滚动"><a href="#滚轮滚动和移动端滚动" class="headerlink" title="滚轮滚动和移动端滚动"></a>滚轮滚动和移动端滚动</h4><p>滚轮滚动和移动端滚动主要依靠 window 的监听事件，根据传入的 event 属性，计算出页面是应该向上还是向下滚动，将需要滚动的方向作为参数传递给处理函数 handler。</p><p>因为代码略长，因此不全部显示在文章中，只显示处理函数相关逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scrollHandler</span>(<span class="hljs-params">direction</span>) &#123;<br>  <span class="hljs-comment">// 防止重复触发滚动事件</span><br>  <span class="hljs-keyword">if</span> (timer != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (direction === <span class="hljs-string">&quot;down&quot;</span>) &#123;<br>    _this.<span class="hljs-title function_">changePage</span>(_this.<span class="hljs-property">nextIndex</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    _this.<span class="hljs-title function_">changePage</span>(_this.<span class="hljs-property">prevIndex</span>);<br>  &#125;<br>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-literal">null</span>;<br>  &#125;, <span class="hljs-number">500</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的一点是，移动端做滚动判断时，要求 touches 和 changedTouches 之间需要一定的间隔，不然容易误触发滚动事件。</p><h4 id="options-属性的分发"><a href="#options-属性的分发" class="headerlink" title="options 属性的分发"></a>options 属性的分发</h4><p>为了使使用者更加方便地编写页面内容而不在意具体的页面序号，我采用了自动对 page 内的 option 赋值的方法。其实现原理是在 App.vue 文件中，使用钩子函数 mounted，对 page 中的 option 属性进行设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mounted () &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child, index</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// 动态设置各个page内的options</span><br><span class="hljs-keyword">if</span> (child.<span class="hljs-property">option</span> === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">let</span> childOption = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>[index];<br><span class="hljs-variable language_">this</span>.$set(childOption,<span class="hljs-string">&#x27;index&#x27;</span>,index+<span class="hljs-number">1</span>);<br>child.<span class="hljs-property">option</span> = childOption;<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="高级属性：新的钩子函数"><a href="#高级属性：新的钩子函数" class="headerlink" title="高级属性：新的钩子函数"></a>高级属性：新的钩子函数</h4><p>为了满足部分使用者的需求，我在设置了两个钩子函数：beforeLeave 和 afterEnter。</p><p>这两个钩子函数可以设置在对应页面的 options 属性对象中，并且含有一个默认的参数，为对应页面的 page 组件实例对象。</p><p>其实现方式为在原先的 changePage 函数（App.vue）内添加新的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">changePage (index) &#123;<br><span class="hljs-comment">// beforeLeave</span><br><span class="hljs-keyword">let</span> beforeIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> leaveFunction = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>[beforeIndex].<span class="hljs-property">beforeLeave</span>;<br><span class="hljs-keyword">typeof</span> leaveFunction === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; leaveFunction.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[beforeIndex]);<br><span class="hljs-comment">// 改变page</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> = index;<br><span class="hljs-comment">// afterEnter</span><br><span class="hljs-keyword">let</span> nextIndex = index-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> enterFunction = <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>[nextIndex].<span class="hljs-property">afterEnter</span>;<br><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">typeof</span> enterFunction === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; enterFunction.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[nextIndex]);<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章记录了我开发一个 FullPage 页面的总体流程，将主要的逻辑重新顺理了一遍，还有一些小的细节没有写在文章中，有兴趣的可以去<a href="https://github.com/kainstar/vue-fullpage">具体的项目页面</a>看源码，当然您要是觉得写得还可以，希望给个 star(<em>^__^</em>) ，如果您有什么想法，欢迎给我留言或加我的 QQ 私聊。</p>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>fullpage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML5特性——Notification</title>
    <link href="/archives/2016/12/20/HTML5%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%E2%80%94Notification/"/>
    <url>/archives/2016/12/20/HTML5%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%E2%80%94Notification/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>恩……开了一个新坑——<strong>HTML5 特性介绍</strong>，用来介绍一些 HTML5 中可能用得到的新特性。</p><p>之所以开这个坑，是因为今天在刷知乎时，看到了一个网页聊天室，这个聊天室能够在我浏览其他网页时也提醒我接收到了新信息，因此对这个功能产生了兴趣。经过查询，知道了这个功能叫做 Notification，是 HTML5 实现的一个新特性，既然已经知道了这个特性的名称，自然不能不对它简单地研究一番了。</p><p>之后如果看到有什么有趣的 HTML5 特性，我也会对它“研究”一番，然后写一篇简单的介绍文章加入到这个系列中的，那么现在让我们先来看一看本次的主角——Notification 吧。</p><span id="more"></span><style>.notification-btn {    display: block;    border: none;    padding: 5px 15px;    line-height: 30px;    color: #fff;    margin: 10px;    background-color: #7778df;}.notification-btn:hover {    box-shadow: 2px 2px 3px #aaa;}.notification-btn:active {    box-shadow: -1px -1px 3px #999 inset;    color: #333;}</style><h2 id="Notification-简介"><a href="#Notification-简介" class="headerlink" title="Notification 简介"></a>Notification 简介</h2><p>在传统的网页体验中，当用户不在浏览网页时，无法由浏览器主动告知用户有新信息，必须等到用户重新开始浏览网页才知道有新消息，这对一些时效性要求比较强的网页应用来说是个很大的问题。</p><p>Notification 是 HTML5 实现的一个消息通知机制，用来为用户设置和显示桌面通知，即会在桌面的右下角弹出一个长方形带消息的窗口，无论用户是否在浏览你的网页。（效果如下图）</p><p>但是因为各种浏览器对 Notification 特性的支持不一，所以会出现 Notification、webkitNotification 和 mozNotification 的三种实现，而且在不同类型和版本的浏览器下提供的参数和 API 不一致，这对开发很不友好</p><p>因此在这里推荐使用 <a href="https://github.com/ttsvetko/HTML5-Desktop-Notifications">HTML5-Desktop-Notifications</a> 这个 polyfill，它对 Notification 进行了实现，使开发者不必考虑浏览器兼容性，可以方便地使用 Notification 特性</p><p>API 参考网站: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification">Notification - Web API</a></p><p><strong>注意！必须在服务器中运行才会有桌面通知效果！</strong></p><h2 id="Notification-的简单实例"><a href="#Notification-的简单实例" class="headerlink" title="Notification 的简单实例"></a>Notification 的简单实例</h2><p>下面我们来看具体的 Notification 实例</p><h3 id="检测特性可用性"><a href="#检测特性可用性" class="headerlink" title="检测特性可用性"></a>检测特性可用性</h3><p>在正式演示 Notification 之前，我们需要先验证 Notification 是否被支持：</p><figure class="highlight javascript"><figcaption><span>验证能否使用Notification</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> validate_notification-btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;validate-notification-btn&quot;</span>);<br>validate_notification-btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Notification</span> != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;notification 可用!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;notification 不可用!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上面这段代码，可以验证 Notification 垫片是否已经发挥了作用</p><p><button type="button" class="notification-btn" id="validate-btn">检验特性可用性</button></p><h3 id="发送一个简单的-Notification"><a href="#发送一个简单的-Notification" class="headerlink" title="发送一个简单的 Notification"></a>发送一个简单的 Notification</h3><p>使用</p><figure class="highlight js"><figcaption><span>如何使用Notification</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> notification = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>(<span class="hljs-string">&quot;嗨(⊙▽⊙)&quot;</span>, &#123;<br>    <span class="hljs-attr">body</span>: <span class="hljs-string">&quot;这里是一个提醒的正文哦 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄&quot;</span>,<br>    <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;/images/head.jpg&quot;</span>,<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">var</span> test1_notification_btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test1-notification-btn&quot;</span>);<br>test_notification_btn1.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Notification</span>.<span class="hljs-property">permission</span> === <span class="hljs-string">&quot;granted&quot;</span>) &#123;<br>    <span class="hljs-title function_">notify</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title class_">Notification</span>.<span class="hljs-title function_">requestPermission</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">permission</span>) &#123;<br>      <span class="hljs-keyword">if</span> (permission === <span class="hljs-string">&quot;granted&quot;</span>) &#123;<br>        <span class="hljs-title function_">notify</span>();<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><button type="button" class="notification-btn" id="test1-btn">点击查看 Notification</button></p><h2 id="Notification-的内容介绍"><a href="#Notification-的内容介绍" class="headerlink" title="Notification 的内容介绍"></a>Notification 的内容介绍</h2><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>Notification 的静态属性：<strong>permission</strong> —— 表明通知授权状态的字符串，它的值有三个：</p><ol><li><strong>denied</strong> 表示用户拒绝了通知的显示</li><li><strong>granted</strong> 表示用户允许了通知的显示</li><li><strong>default</strong> 表示默认状态，因为不知道用户的选择，所以浏览器的行为与 denied 时相同</li><li><strong>notsupported</strong> 在使用了 HTML5-Desktop-Notifications 垫片之后，会有第四个值，表示浏览器不支持(未实现）Notification 特性</li></ol><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Notification 的静态方法：<strong>requestPermission([callback])</strong> —— 向用户请求允许使用 Notification，但是这个方法只能通过用户行为调用（例如点击），其他方式无法调用。</p><p>使用这个方法时可以传入一个回调函数，这个回调函数有一个参数，参数的值为请求之后的通知授权的状态</p><figure class="highlight js"><figcaption><span>requestPermission方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Notification</span>.<span class="hljs-title function_">requestPermission</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(status);<br>&#125;);<br></code></pre></td></tr></table></figure><p>你也可以用 then 的异步方法完成操作：</p><figure class="highlight js"><figcaption><span>requestPermission方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Notification</span>.<span class="hljs-title function_">requestPermission</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(status);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="构造函数-初始化方法"><a href="#构造函数-初始化方法" class="headerlink" title="构造函数(初始化方法)"></a>构造函数(初始化方法)</h3><p>Notification 的初始化方法为：</p><figure class="highlight js"><figcaption><span>requestPermission方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> notification = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>(title, options);<br></code></pre></td></tr></table></figure><p><strong>title</strong>是一个字符串，表示这个通知的标题</p><p><strong>options</strong>是一个对象，是一个可选参数，根据 options 包含的属性对 Notification 进行设定</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>构造方法会返回一个 notification 实例，可以直接访问这个实例下的各种实例属性</p><ul><li><strong>title</strong>：通知内所显示的文本标题,用构造方法的第一个参数初始化</li><li><strong>body</strong>：通知内所显示的文本内容</li><li><strong>icon</strong>：通知左侧显示的图片，一个字符串，表示图片的 URL 地址</li><li><strong>dir</strong>：通知文本的显示方向，有三个参数：”auto”,”ltr”,”rtl”（但是好像没有什么区别）</li><li><strong>lang</strong>：通知使用的语言（不常用）</li><li><strong>tag</strong>：通知的 ID，是一个字符串，用于区分不同的 Notification。如果有一条新通知和一条旧通知具有一个相同的标记，并且还没有被显示，那么这条新通知将会替换旧通知。如果旧通知已经显示出来了，那么旧通知将会被关闭，新通知将会被显示出来。</li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>notification 实例有一个实例方法 —— **close()**，调用这个方法可以关闭对应的 notification</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>notification 实例有四个可以设置的触发事件：<strong>show</strong>（提醒显示时）,<strong>click</strong>（提醒被点击时）,<strong>error</strong>（提醒出错时）,<strong>close</strong>（提醒关闭时），通过设置 <strong>on+事件名</strong> 的属性来设置触发事件</p><figure class="highlight js"><figcaption><span>requestPermission方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> notification = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>(<span class="hljs-string">&quot;嗨(⊙▽⊙)&quot;</span>, &#123;<br>  <span class="hljs-attr">body</span>: <span class="hljs-string">&quot;这里是一个提醒的正文哦 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄&quot;</span>,<br>  <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;/images/head.jpg&quot;</span>,<br>&#125;);<br>notification.<span class="hljs-property">onshow</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;notification 已被打开&quot;</span>);<br>&#125;;<br>notification.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">close</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;notification 已被点击&quot;</span>);<br>&#125;;<br>notification.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;notification 已被关闭&quot;</span>);<br>&#125;;<br>notification.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;notification 出错&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p><button type="button" class="notification-btn" id="test2-btn">测试事件处理</button></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>作为本系列的第一篇文章，不知道写成这样能否算是达到及格水平，若是有前辈看到文章，希望能给予指点。</p><script src="//cdn.bootcss.com/HTML5Notification/3.0.0/Notification.js"></script><script src="/code/notification-demo.js"></script>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html5</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github pages中如何引用其他项目</title>
    <link href="/archives/2016/08/21/github-pages%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE/"/>
    <url>/archives/2016/08/21/github-pages%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为最近在学习 React，学习慕课网上的 React 课程搭建了一个基于 React 的图片画廊，因为视频比较老，使用新版本工具时自己踩了不少坑，最后发布项目 DEMO 的时候折腾了很久，最后终于知道如何在 github pages 页面中引用别的项目的 DEMO 了（不知道如何创建 github Pages 的，可以去我的另一篇博客<a href="http://tianlajiangbula.com/2016/08/09/hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/#github">hexo 搭建记录</a>中查看），在此就把引用项目 DEMO 的过程做个记录。</p><span id="more"></span><h2 id="创建-DEMO-的过程"><a href="#创建-DEMO-的过程" class="headerlink" title="创建 DEMO 的过程"></a>创建 DEMO 的过程</h2><h3 id="事前检查"><a href="#事前检查" class="headerlink" title="事前检查"></a>事前检查</h3><p>首先你要检查一下自己本地的 DEMO 能否正常运作，我指的是不用搭建本地服务器，可以直接在浏览器中查看</p><p>如果可以正常运作，则可以进入下一步，否则请把你的 DEMO 中的文件路径全部改为相对路径，这样应该就能在本地查看了</p><h3 id="将-DEMO-上传"><a href="#将-DEMO-上传" class="headerlink" title="将 DEMO 上传"></a>将 DEMO 上传</h3><ol><li><p>首先在终端中进入到你的项目目录</p></li><li><p>创建一个新的 gh-pages 分支</p><pre><code class="hljs">git branch gh-pagesgit checkout gh-pages</code></pre></li><li><p>将这个分支下的内容替换成你的 DEMO 内容</p></li><li><p>将这个分支上传</p><pre><code class="hljs">git add -Agit commit -m &quot;你的说明内容&quot;git push -u origin gh-pages</code></pre></li><li><p>好了，现在你可以在你的 github Pages 页面下查看这个 DEMO 了，网址就是:</p><p>https:&#x2F;&#x2F;你的账号名.github.io&#x2F;你的项目名</p><p>如果你的 DEMO 有 index.html 页面，则会直接跳转到 index 页面，若是没有，则需要手动添加跳转路径</p></li></ol><h3 id="更加简单的-DEMO-上传方式"><a href="#更加简单的-DEMO-上传方式" class="headerlink" title="更加简单的 DEMO 上传方式"></a>更加简单的 DEMO 上传方式</h3><p>现代前端有着许许多多的脚手架工具，在复杂的项目目录中找到编译完后的内容重新创建 DEMO 可能会很麻烦，因此可以用更简单的一句命令来创建 DEMO</p><pre><code class="hljs">git subtree push --preifx=dist origin gh-pages</code></pre><p>这句命令可以帮助你创建一个空的 gh-pages 分支并将某个文件夹下的内容放置到这个分支下。</p><p>其中，dist 可以替换成你的 DEMO 所在的文件夹路径。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是有关于使用 gh-pages 分支和 github pages 在 github pages 页面下引用其他项目的 DEMO 的方法，顺便放一下我使用这个方法完成的 DEMO：</p><p><a href="https://kainstar.github.io/gallery-by-react">基于 React 的图片画廊</a></p><p>看到这篇文章的人或者其他遇到这方面困难的人，希望我的文章能够帮助到你。</p>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>github pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的正则学习笔记</title>
    <link href="/archives/2016/08/17/JavaScript%E7%9A%84%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/archives/2016/08/17/JavaScript%E7%9A%84%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正则表达式（Regular Expression）是一种常见的用于处理字符串的操作公式。根据事先定义好的一些字符的组合的规则来检索，过滤，替换字符串。它的优点有：</p><ol><li>可以用简单的方式做到字符串的复杂控制</li><li>灵活性，功能性强</li></ol><p>但是正则表达式也有一个致命缺点，就是对于刚刚接触正则表达式的人来说，它实在是太难懂了，这也导致了很多人在一开始学正则表达式时因为无法理解而放弃。</p><p>我在慕课网上学习时看到一个<a href="http://www.imooc.com/learn/706">关于 JavaScript 的正则表达式的课程</a>，本着巩固自身认识，也方便日后查看的心态，将其内容总结成该博客笔记。</p><span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li><p>本文使用的语言是 JavaScript，会使用到一些 JavaScript 中的正则表达式使用方法，对于其他语言的正则表达式用法请查阅官方文档或其他资料。</p></li><li><p>本文中用字符串的 replace 方法来展示正则表达式的使用效果，该方法的作用是根据正则表达式来对字符串内匹配的内容进行替换</p></li></ol><h2 id="正则表达式笔记"><a href="#正则表达式笔记" class="headerlink" title="正则表达式笔记"></a>正则表达式笔记</h2><h3 id="JavaScript-的正则表达式初始化方法"><a href="#JavaScript-的正则表达式初始化方法" class="headerlink" title="JavaScript 的正则表达式初始化方法"></a>JavaScript 的正则表达式初始化方法</h3><ol><li><p>使用字面量实例化（书写方式：把正则内容写到两个斜线中间）</p><pre><code class="hljs">var reg = /\bis\b/g;</code></pre></li><li><p>使用 RegExp 对象实例化</p><pre><code class="hljs">    var reg = new RegExp(&#39;\\bis\\b&#39;,&#39;g&#39;);</code></pre><p>注意：使用 RegExp 对象实例化时，因为参数是字符串，所以要多加一个反斜线\来转义反斜线</p></li></ol><h3 id="正则表达式的修饰符"><a href="#正则表达式的修饰符" class="headerlink" title="正则表达式的修饰符"></a>正则表达式的修饰符</h3><p>在字符串中是最后一个斜杠后所加的字符就是正则表达式的修饰符（在正则构造函数中是第二个参数），可以多个修饰符叠加使用。</p><ol><li><p><strong>g: global</strong> 表示全文搜索，不添加时搜索到第一个匹配就停止搜索</p><pre><code class="hljs">var reg = /\bis\b/g;var raw = &#39;He is a boy! He like playing game! Who is he?&#39;;raw.replace(reg,&#39;IS&#39;);//替换结果：He IS a boy! He like playing game! Who IS he?</code></pre></li><li><p><strong>i: ignore case</strong> 表示忽略大小写，默认情况下大小写敏感</p><pre><code class="hljs">var reg = /a/ig;var raw = &#39;AaaA&#39;;raw.replace(reg,&#39;b&#39;);//替换结果：bbbb</code></pre></li><li><p><strong>m:multiple lines</strong> 多行搜索</p><pre><code class="hljs">var reg = /a/gm;// 反斜线\可以表示多行字符串var raw = &#39;aa\            dcba\            abcd&#39;;raw.replace(reg,&#39;A&#39;);//替换结果：AAdcbAAbcd</code></pre></li></ol><h3 id="基本类型字符"><a href="#基本类型字符" class="headerlink" title="基本类型字符"></a>基本类型字符</h3><p>在正则表达式中，有两种基本类型字符：原义文本字符和元字符。</p><p>原义文本字符指的是原本意义的字符，写了什么就是什么，例如：<code>var reg = /a/ </code>表示创建一个匹配字符 a 的正则表达式。</p><p>元字符指的是在正则中含有特殊含义（用来代替一个或多个字符）的非字母字符(*+?$^.|(){}[]和一系列\转义字符，在之后会详细解释) 例如：<code>var reg = /\d/</code>表示创建一个匹配一个数字的正则表达式。</p><h3 id="元字符详解"><a href="#元字符详解" class="headerlink" title="元字符详解"></a>元字符详解</h3><h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p>用元字符[]来构建一个简单的类，把在[]中的字符归为一类，表达式可以匹配这一类的字符。例如：[abc]则是将 a、b、c 归为一类。表达式可以匹配 a 或 b 或 c</p><pre><code class="hljs">var reg = /[abc]/g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X1X2X3d4</code></pre><h4 id="字符类取反"><a href="#字符类取反" class="headerlink" title="字符类取反"></a>字符类取反</h4><p>用元字符^创建反向类，表示不属于这一类的内容。例如：[^abc]则是表示不是字符 a 或 b 或 c 的内容</p><pre><code class="hljs">var reg = /[^abc]/g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：aXbXcXXX</code></pre><p>但是如果要匹配数字 0 到 9，是不是要把 9 个数字都写一遍呢？不是，为了简化书写，可以在字符类中使用 - 符号表示范围，如果想在字符类中匹配 - 符号，就要把 - 符号加到字符类开头或者结尾处（在字符类内部可以连续写好几个范围类）</p><pre><code class="hljs">var reg = /[-0-9a-zA-Z]/g;//0-9 等同于 0123456789var raw = &#39;2016-08-16 NanJing&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：XXXXXXXXXX XXXXXXX</code></pre><h4 id="预定义字符类"><a href="#预定义字符类" class="headerlink" title="预定义字符类"></a>预定义字符类</h4><p>用来匹配常见的字符类的一类元字符，可以分为边界匹配字符和非边界匹配字符</p><p><strong>非边界匹配字符：</strong></p><p>. 表示除了回车和换行以外的所有字符（[^\r\n]）</p><pre><code class="hljs">var reg = /./g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：XXXXXXXX</code></pre><p>\d 表示数字字符（[0-9]）</p><pre><code class="hljs">var reg = /\d/g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：aXbXcXdX</code></pre><p>\D 表示非数字字符（[^0-9]）</p><pre><code class="hljs">var reg = /\D/g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X1X2X3X4</code></pre><p>\s 表示空白符（[\t\n\x0B\f\r]）</p><pre><code class="hljs">var reg = /\s/g;var raw = &#39;a1 b2 c3 d4&#39;;var result = raw.replace(reg,&#39;X&#39;);//替换结果：a1Xb2Xc3Xd4</code></pre><p>\S 表示非空白符（[^\t\n\x0b\f\r]）</p><pre><code class="hljs">var reg = /\S/g;var raw = &#39;a1 b2 c3 d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：XX XX XX XX</code></pre><p>\w 单词字符(字母、数字、下划线)（[a-zA-Z_0-9]）</p><pre><code class="hljs">var reg = /\w/g;var raw = &#39;a1 b2 c3 d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：XX XX XX XX</code></pre><p>\W 非单词字符（[^a-za-z_0-9]）<br>var reg &#x3D; &#x2F;\W&#x2F;g;<br>var raw &#x3D; ‘a1 b2 c3 d4’;<br>raw.replace(reg,’X’);<br>&#x2F;&#x2F;替换结果：a1Xb2Xc3Xd4</p><p><strong>边界匹配字符：</strong></p><p>^ 表示开始</p><pre><code class="hljs">var reg = /^./g;var raw = &#39;a1 b2 c3 d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X1 b2 c3 d4</code></pre><p>$ 表示结束</p><pre><code class="hljs">var reg = /.$/g;var raw = &#39;a1 b2 c3 d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：a1 b2 c3 dX</code></pre><p>\b 表示单词边界</p><pre><code class="hljs">var reg = /\ba1\b/g;var raw = &#39;a1a1 a1&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：a1a1 X</code></pre><p>\B 表示非单词边界</p><pre><code class="hljs">var reg = /\Ba1\b/g;var raw = &#39;a1a1 a1&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：a1X a1</code></pre><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>正则表达式中的量词可以用来表示匹配的次数</p><p>? 表示零次或一次(有或没有)</p><pre><code class="hljs">var reg = /ab?c/g;var raw = &#39;ac abc abbc&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X X abbc</code></pre><p>+ 表示一次或多次(至少出现一次)</p><pre><code class="hljs">var reg = /ab+c/g;var raw = &#39;ac abc abbc&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：ac X X</code></pre><p>* 表示出现零次或一次或多次(任意次数)</p><pre><code class="hljs">var reg = /ab+c/g;var raw = &#39;ac abc abbc&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X X X</code></pre><p>{n} 表示出现 n 次</p><pre><code class="hljs">var reg = /ab&#123;1&#125;c/g;var raw = &#39;ac abc abbc&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：ac X abbc</code></pre><p>{n,m} 表示出现 n 次到 m 次</p><pre><code class="hljs">var reg = /ab&#123;1,2&#125;c/g;var raw = &#39;ac abc abbc abbbc&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：ac X X abbbc</code></pre><p>{n,} 表示至少出现 n 次</p><pre><code class="hljs">var reg = /ab&#123;1&#125;c/g;var raw = &#39;ac abc abbc abbbc&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：ac X X X</code></pre><h3 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h3><p><strong>贪婪模式：</strong>尽可能多的进行匹配，匹配成功后继续尝试直到无法匹配（正则表达式在默认情况下就是贪婪模式）</p><pre><code class="hljs">var reg = /\d&#123;1,3&#125;/;var raw = &#39;12345&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X45</code></pre><p><strong>非贪婪模式：</strong>尽可能少的进行匹配，一旦匹配成功就不再继续尝试（用法：在量词后面加上?）</p><pre><code class="hljs">var reg = /\d&#123;1,3&#125;?/;var raw = &#39;12345&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X2345</code></pre><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>用()可以将正则表达式分组成不同的子串（量词可以作用到一个分组）</p><pre><code class="hljs">var reg = /([a-z]\d)&#123;3&#125;/g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：Xd4</code></pre><p><strong>或的表示：</strong>用|可以表示或，使用或时最好用分组括号将几个项包括在一起，方便查看理解</p><pre><code class="hljs">var reg = /a(11|22)/g;var raw = &#39;a11 a22 a33&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X X a33</code></pre><p><strong>分组的反向引用：</strong>用$符号表示捕获到分组的内容，可以用$加上对应序号的形式引用</p><pre><code class="hljs">var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g;var raw = &#39;2016-08-18&#39;;raw.replace(reg,&#39;$2/$3/$1&#39;);//替换结果：08/18/2016</code></pre><p><strong>忽略分组：</strong>如果不希望捕获到某些分组，只需要在分组前加上?:即可</p><pre><code class="hljs">var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(?:\d&#123;2&#125;)/g;var raw = &#39;2016-08-18&#39;;raw.replace(reg,&#39;$2/$1&#39;);//替换结果：08/2016</code></pre><h3 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h3><p>正则表达式是从文本头部向尾部进行解析，文本尾部方向就是‘前’。前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言。（JavaScript 不支持后顾，因此在本文中不对后顾进行解释）</p><p>符合断言的称为<strong>“肯定&#x2F;正向”</strong>匹配，不符合的称为<strong>“否定&#x2F;负向”</strong>匹配。</p><p>用 exp 表示要匹配的正则表达式，assert 表示断言部分(也是一个正则)来说明前瞻所用的公式。</p><p><strong>正向前瞻：</strong> exp(?&#x3D;assert)</p><pre><code class="hljs">var reg = /\w(?=\d)/g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：X1X2X3X4</code></pre><p><strong>负向前瞻：</strong> exp(?!assert)</p><pre><code class="hljs">var reg = /\w(?!\d)/g;var raw = &#39;a1b2c3d4&#39;;raw.replace(reg,&#39;X&#39;);//替换结果：aXbXcXdX</code></pre><p>注：断言部分不参与匹配，仅作为一个验证部分存在。</p><p>常用的正则表达式所需的知识点已经写在了上面，接下来会介绍一下 JavaScript 中正则表达式有关的属性和方法</p><hr><h3 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h3><p>RegExp 对象的属性：</p><p><strong>global:</strong> 是否全文搜索，默认为 false</p><p><strong>ignore case:</strong> 是否大小写敏感，默认为 false</p><p><strong>multiline:</strong> 多行搜素，默认为 false</p><p><strong>lastIndex:</strong> 当前表达式匹配内容的最后一个字符的下一个位置</p><p><strong>source:</strong> 正则表达式的文本字符串</p><p>RegExp 对象的方法：</p><p><strong>test(str)</strong> 测试字符串 str 中是否存在能匹配正则表达式的部分，有则返回 true，没有则返回 false。该方法每次执行后，lastIndex 都会发生相应的改变</p><p><strong>exec(str)</strong> 使用正则表达式模式对字符串执行搜索，并将更新全局 RegExp 对象的属性以反映匹配结果。如果没有匹配的文本就返回 null，有就返回一个结果数组。</p><pre><code class="hljs">这个结果数组有两个属性：    index 声明匹配文本的第一个字符的位置    input 存放被检索的字符串 str除此之外，使用非全局的正则对象的exec方法时，返回的结果数组的第一个元素是匹配到的字符串，第二个元素是匹配到的第一个分组，第三个元素是匹配到的第二个分组（以此类推）</code></pre><h3 id="字符串-String-对象"><a href="#字符串-String-对象" class="headerlink" title="字符串 String 对象"></a>字符串 String 对象</h3><p>字符串 String 的方法：</p><p><strong>search(str||reg)</strong> 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，方法返回第一个匹配结果的 index，搜索不到就返回-1。search 方法不执行全局匹配，会忽略修饰符 g，并且总是从字符串的开始位置进行检索。</p><p><strong>match(reg)</strong> 方法检索字符串，找到一个或多个和正则表达式相匹配的文本，修饰符 g 有影响。match 非全局调用的返回和 RegExp 对象的 exec 方法的返回一样；而全局调用返回的是字符串中所有的匹配子串，没有 index 和 input 属性</p><p><strong>split()</strong> 方法用于分割字符串成数组，其分割符可以用正则来表示</p><p><strong>replace()</strong> 方法用于替换字符串中的一部分成另外一部分，replace 方法有三种参数传递方式：</p><ol><li><p><strong>replace(str,replaceStr)</strong></p><p>示例：</p><pre><code class="hljs">&#39;a1b2c3d4&#39;.replace(&#39;a&#39;, &#39;X&#39;);//替换结果：X1b2c3d4</code></pre></li><li><p><strong>replace(reg,replaceStr)</strong></p><p>示例：</p><pre><code class="hljs">&#39;a1b2c3d4&#39;.replace(/\d/g, &#39;X&#39;);//替换结果：aXbXcXdX</code></pre></li><li><p><strong>replace(reg,function)</strong> 其中 function 在每次匹配替换的时候都被调用，它有四种参数:</p><ol><li>匹配字符串 <strong>match</strong></li><li>正则表达式分组内容，有多少个分组就有多少个该参数 <strong>group1,group2,…</strong></li><li>匹配项在字符串中的位置 <strong>index</strong></li><li>原字符串 <strong>origin</strong></li></ol></li></ol><p>示例:</p><pre><code class="hljs">&#39;a1b2c3d4&#39;.replace(/\d/g, function(match,index,origin) &#123;    console.log(index);    return parseInt(match)+1;&#125;)//替换结果：a2b3c4d5&#39;a1b2c3d4&#39;.replace(/(\d)(\w)(\d)/g, function(match,group1,group2,group3,index,origin) &#123;    console.log(index);    return group1+group3;&#125;)//替换结果：a12c34</code></pre><hr><p>到此为止，介绍 JavaScript 的正则表达式的笔记全部完成，对阅读到这里的读者表示感谢，也希望这篇笔记能够帮上你的忙。</p>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建记录</title>
    <link href="/archives/2016/08/09/hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/archives/2016/08/09/hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近，在学习前端的过程中，遇到不少问题，每次遇到问题都要去网上查相应的资料，很麻烦，而且经常查了又忘，因此想找个地方把自己学习过程中遇到的问题都记录下来，也算是复习。</p><p>首先是搭建这个博客的过程，经过资料查询，觉得<a href="https://hexo.io/zh-cn/">Hexo</a>这个静态博客搭建工具不错，而且还可以学习 git 和 github，把静态博客页面放在 github page 上，也是省下了一笔服务器费用(毕竟这个记录用的博客也不怎么用得到后台)。</p><span id="more"></span><h2 id="事前说明"><a href="#事前说明" class="headerlink" title="事前说明"></a>事前说明</h2><ol><li>我所使用的操作系统是 Windows，因此文章中使用到的工具都是 Windows 版的，请结合自身电脑的系统版本下载对应的 32 位和 64 位工具。</li><li>本文书写过程中参考了<a href="http://e12e.com/2016/02/17/github%E4%B8%8A%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/">github 上搭建 hexo 博客</a>和<a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一个独立博客——简明 Github Pages 与 Hexo 教程</a>两篇文章，在此向两位作者表示感谢。</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在用 Hexo 搭建博客之前，需要事先用你的电脑准备几样东西</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>首先你需要安装的是<a href="https://git-scm.com/downloads">Git</a>，这是一个分布式版本控制系统，主要用来进行将博客页面上传到 github 的操作，其安装方式十分简单，只需要不停地点击 next 即可。</p><p>虽然在使用 Hexo 的过程中不需要怎么使用 Git，但是如果你对 Git 的使用方式有兴趣，我建议你可以去<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的 Git 教程</a>看一下，这里非常详细地介绍了有关于 Git 的一系列知识。</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p><a href="https://nodejs.org/en/">Node.js</a>是 Hexo 的运行环境，安装过程和 Git 一样，直接安装即可。</p><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>在将你的博客上传到 github 前，你先要有一个 github 账号才行，进入<a href="https://www.github.com/">github 的官网</a>，注册一个你的 github 账号（怎么注册应该就不用说了吧），然后点击页面右上角的加号，选择<strong>New repository</strong>，建立一个名为 <code>[你的账号名].github.io</code> 的仓库</p><p>完成了 github 仓库的创建之后，我们需要将本地 Git 项目和你的 github 仓库建立联系，这里要用到的就是 SSH Key。</p><h3 id="生成新的-SSH-Key"><a href="#生成新的-SSH-Key" class="headerlink" title="生成新的 SSH Key"></a>生成新的 SSH Key</h3><p>打开桌面上安装好的 Git Bash（或者在右键菜单中选择 Git Bash Here），输入下面的内容（在 Git Bash 中$号是自动生成的，不需要输入）：</p><pre><code class="hljs">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;直接回车就好&gt;</code></pre><p>然后系统会要你输入密码：</p><pre><code class="hljs">Enter passphrase (empty for no passphrase):&lt;输入密码&gt;Enter same passphrase again:&lt;再次输入密码&gt;</code></pre><p>输入完密码后 ssh key 就生成完毕了。</p><h3 id="添加-SSH-Key-到-GitHub"><a href="#添加-SSH-Key-到-GitHub" class="headerlink" title="添加 SSH Key 到 GitHub"></a>添加 SSH Key 到 GitHub</h3><p>在本机设置 SSH Key 之后，需要添加到 GitHub 上，以完成 SSH 链接的设置。</p><ol><li><p>打开 C:\Users\Administrator.ssh\id_rsa.pub 文件，这个文件就是刚刚生成的密钥文件，用编辑器打开文件并复制文件里的内容。</p></li><li><p>登陆 github，点击右上角头像下拉菜单中的 Settings，找到 SSH and GPG keys，选择 New SSH Key，将复制的内容粘贴到 Key 一栏里，点击 Add SSH Key 即可完成添加。</p></li><li><p>回到 Git Bash 中，输入以下命令，看是否设置成功：</p><pre><code class="hljs">$ ssh -T git@github.com</code></pre></li><li><p>如果是下面的反馈：</p><pre><code class="hljs">The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>输入 yes，然后会看到：</p><pre><code class="hljs">Hi cnfeat! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></li><li><p>此时已经可以通过 SSH 连接到 github 了，但是你还需要完善一些个人信息</p><p>在 Git Bash 中输入下面两条命令，进行个人信息的设置</p><pre><code class="hljs">$ git config --global user.name &quot;cnfeat&quot;// 填写用户名$ git config --global user.email &quot;cnfeat@gmail.com&quot;// 填写邮箱</code></pre></li></ol><p>到此为止，本地 Git 到远程 github 仓库的配置全部完成了，下面开始正式进入有关 Hexo 的内容了。</p><hr><h2 id="搭建-Hexo-静态博客"><a href="#搭建-Hexo-静态博客" class="headerlink" title="搭建 Hexo 静态博客"></a>搭建 Hexo 静态博客</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装 Hexo 不需要去什么官方网站下载，只需要你打开 Git Bash，在里面输入下面的命令：</p><pre><code class="hljs">$ npm install hexo-cli -g</code></pre><p>等待 Hexo 安装完成即可。</p><h3 id="生成本地博客"><a href="#生成本地博客" class="headerlink" title="生成本地博客"></a>生成本地博客</h3><p>在要创建 Hexo 的目录下打开 Git Bash，输入：</p><pre><code class="hljs">$ hexo init myblog</code></pre><p>myblog 是存放博客文件的目录，可以随自己的喜好修改</p><p>继续输入：</p><pre><code class="hljs">$ cd myblog</code></pre><p>进入到博客文件夹中，进入到文件夹后输入：</p><pre><code class="hljs">$ npm install // 安装hexo所需的依赖$ npm install hexo-deployer-git --save// 安装将hexo博客向github上传的模块$ npm install hexo-server --save// 安装hexo服务器模块，用于本地预览博客</code></pre><p>到此就完成 Hexo 静态博客的基本搭建了。</p><h3 id="浏览效果"><a href="#浏览效果" class="headerlink" title="浏览效果"></a>浏览效果</h3><p>输入以下命令：</p><pre><code class="hljs">$ hexo g// 等同于hexo generate，生成博客静态文件$ hexo s// 等同于hexo server，启动一个本地服务器用来浏览博客效果</code></pre><p>在浏览器中输入<code>http://localhost:4000</code>可以看到此时的博客页面</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开博客目录下的_config.yml 文件，这个文件就是 Hexo 用于生成静态网页的配置文件，其中的各种参数可以参考<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo 官网的文档</a>来进行设置，我们这里只修改用于部署该博客到 github 的参数。</p><p>翻到文件的最下方，将 deploy 标签改成：</p><pre><code class="hljs">deploy:    type: git    repo: https://github.com/yourname/yourname.github.io.git</code></pre><p>注意：在 yml 文件中，冒号后面必须有一个空格，不然执行部署命令的时候会报错。</p><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><ol><li><p>在 Git Bash 中输入：</p><pre><code class="hljs">$ hexo new &quot;article name&quot;</code></pre></li><li><p>在博客目录下的 source 文件夹中的_post 文件夹里找到你新建的 md 文件，使用 Markdown 语法书写你的文章</p></li><li><p>最后使用 <code>hexo g</code> 命令生成相应的静态文件即可。</p></li></ol><h3 id="部署静态博客到-github"><a href="#部署静态博客到-github" class="headerlink" title="部署静态博客到 github"></a>部署静态博客到 github</h3><p>在 Git Bash 中输入：</p><pre><code class="hljs">$ hexo d// 等同于hexo deploy</code></pre><p>等待它将文件上传到 github 即可。</p><h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p>如果你对 Hexo 自带的主题不满意的话，可以去 github 或者<a href="https://hexo.io/themes/">Hexo 官网下的主题页</a>找你中意的主题，将它们下载到博客目录下的 themes 文件夹下，再修改_config.yml 文件中的 theme 标签，即可改变主题（记得使用<code>hexo g</code>命令重新生成静态文件）。</p><hr><h2 id="其他参考资料"><a href="#其他参考资料" class="headerlink" title="其他参考资料"></a>其他参考资料</h2><ol><li><a href="http://www.jianshu.com/p/1e402922ee32/">Markdown——入门指南</a></li><li><a href="https://segmentfault.com/a/1190000002632530">hexo 常用命令笔记</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>github-pages</tag>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
